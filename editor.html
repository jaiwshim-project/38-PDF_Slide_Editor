<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NotebookLM Slide Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/gitbrent/PptxGenJS@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ════════════════════════════════════════
           상단 툴바
           ════════════════════════════════════════ */
        .top-bar {
            height: 48px;
            background: #0f172a;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
            flex-shrink: 0;
        }

        /* 좌측 로고 */
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 24px;
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-icon svg { width: 16px; height: 16px; fill: none; stroke: #fff; stroke-width: 2; }

        .logo-text {
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
            white-space: nowrap;
        }

        .logo-sub {
            font-size: 10px;
            color: #94a3b8;
            font-weight: 400;
            display: block;
            margin-top: -2px;
        }

        /* 중앙 모드 버튼 */
        .mode-buttons {
            display: flex;
            gap: 4px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 3px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .mode-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: #e2e8f0;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            font-family: inherit;
        }

        .mode-btn:hover { color: #ffffff; background: rgba(255,255,255,0.05); }
        .mode-btn.active {
            background: rgba(139,92,246,0.2);
            color: #ffffff;
        }

        .mode-btn kbd {
            font-family: inherit;
            font-size: 10px;
            color: #94a3b8;
            margin-right: 4px;
        }

        /* 우측 버튼들 */
        .top-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-divider {
            width: 1px;
            height: 24px;
            background: rgba(255,255,255,0.1);
            margin: 0 8px;
        }

        .top-btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            background: transparent;
            color: #e2e8f0;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: inherit;
        }
        .top-btn:hover { background: rgba(255,255,255,0.1); }

        .top-btn-delete {
            color: #f87171;
            border-color: rgba(239,68,68,0.3);
        }
        .top-btn-delete:hover { background: rgba(239,68,68,0.1); }
        .top-btn-delete.active {
            background: rgba(239,68,68,0.15);
            border-color: rgba(239,68,68,0.4);
        }

        .top-btn-export {
            background: linear-gradient(to right, #2563eb, #9333ea);
            border: none;
            color: #fff;
        }
        .top-btn-export:hover { opacity: 0.9; }

        /* ════════════════════════════════════════
           도구 모음 바 (상단 바 아래)
           ════════════════════════════════════════ */
        .tool-bar {
            height: 36px;
            background: #0f172a;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 2px;
            flex-shrink: 0;
            z-index: 99;
        }

        .tb-group {
            display: flex;
            align-items: center;
            gap: 1px;
            padding: 0 4px;
        }

        .tb-group + .tb-group {
            border-left: 1px solid rgba(255,255,255,0.1);
            margin-left: 4px;
            padding-left: 8px;
        }

        .tb-btn {
            width: 30px;
            height: 28px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: #e2e8f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.12s;
            position: relative;
        }
        .tb-btn:hover { background: rgba(255,255,255,0.1); color: #ffffff; }
        .tb-btn.active { background: rgba(139,92,246,0.2); color: #c4b5fd; }
        .tb-btn:disabled { opacity: 0.3; cursor: default; }

        .tb-btn svg { width: 16px; height: 16px; stroke: currentColor; fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }

        .tb-btn[title]::after {
            content: attr(title);
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            background: #0f172a;
            border: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            padding: 2px 6px;
            border-radius: 4px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s;
            z-index: 50;
        }
        .tb-btn:hover[title]::after { opacity: 1; }

        .tb-label {
            font-size: 11px;
            color: #e2e8f0;
            padding: 0 6px;
            white-space: nowrap;
        }

        .tb-select {
            height: 24px;
            padding: 0 6px;
            background: rgba(2,6,23,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            outline: none;
        }
        .tb-select option { background: #0f172a; }

        .tb-input {
            width: 48px;
            height: 24px;
            padding: 0 6px;
            background: rgba(2,6,23,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
            text-align: center;
            font-family: inherit;
            outline: none;
        }
        .tb-input:focus { border-color: #8b5cf6; }

        .tb-color {
            width: 24px;
            height: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            padding: 1px;
            background: none;
        }

        /* ════════════════════════════════════════
           메인 3단 레이아웃
           ════════════════════════════════════════ */
        .editor-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* ── 좌측: 슬라이드 썸네일 ── */
        .left-panel {
            width: 160px;
            background: #0f172a;
            border-right: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .left-panel-header {
            padding: 12px 12px 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #94a3b8;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .slide-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .slide-list::-webkit-scrollbar { width: 4px; }
        .slide-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

        .slide-thumb {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            margin-bottom: 6px;
            transition: all 0.15s;
            background: #1e293b;
        }
        .slide-thumb:hover { border-color: rgba(255,255,255,0.2); }
        .slide-thumb.active { border-color: #8b5cf6; box-shadow: 0 0 0 1px #8b5cf6; }

        .slide-thumb.marked-delete {
            opacity: 0.4;
            border-color: #f87171;
        }

        .slide-thumb.marked-delete::after {
            content: 'DELETE';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            font-size: 9px;
            font-weight: 700;
            color: #fff;
            background: rgba(239,68,68,0.8);
            padding: 2px 6px;
            border-radius: 3px;
            letter-spacing: 0.5px;
        }

        .slide-thumb canvas { width: 100%; height: 100%; display: block; }

        .slide-thumb-num {
            position: absolute;
            bottom: 3px;
            left: 6px;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            padding: 1px 5px;
            border-radius: 3px;
        }

        /* ── 중앙: 캔버스 ── */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #020617;
            position: relative;
        }

        .canvas-viewport {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            padding: 24px;
            background:
                linear-gradient(rgba(2,6,23,0.95), rgba(2,6,23,0.95)),
                repeating-conic-gradient(#1e293b 0% 25%, transparent 0% 50%) 0 0 / 20px 20px;
        }

        .canvas-container {
            position: relative;
            box-shadow: 0 4px 32px rgba(0,0,0,0.6);
            border-radius: 2px;
            line-height: 0;
        }

        #mainCanvas {
            display: block;
            border-radius: 2px;
        }

        /* 선택 오버레이 */
        .selection-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            cursor: crosshair;
            z-index: 10;
        }

        .selection-overlay.pan-mode { cursor: grab; }
        .selection-overlay.pan-mode:active { cursor: grabbing; }
        .selection-overlay.delete-mode { cursor: default; }

        .sel-box {
            position: absolute;
            border: 2px dashed #8b5cf6;
            background: rgba(139,92,246,0.12);
            border-radius: 2px;
            pointer-events: none;
        }

        /* 텍스트 편집 레이어 */
        .edit-layer {
            position: absolute;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }

        .edit-layer-header {
            display: flex;
            gap: 3px;
            margin-bottom: 2px;
            justify-content: flex-end;
        }

        .el-btn {
            width: 22px;
            height: 22px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
        }

        .el-btn-ok { background: #10b981; color: #fff; }
        .el-btn-ok:hover { background: #34d399; }
        .el-btn-cancel { background: #ef4444; color: #fff; }
        .el-btn-cancel:hover { background: #f87171; }

        .edit-textarea {
            width: 100%;
            height: 100%;
            border: 1px dashed rgba(88,110,250,0.35);
            background: transparent;
            color: #000;
            padding: 2px 4px;
            font-size: 16px;
            line-height: 1.3;
            resize: none;
            outline: none;
            border-radius: 2px;
            transition: border-color 0.2s;
        }
        .edit-textarea:focus {
            border: 1px solid rgba(88,110,250,0.5);
        }

        /* 텍스트 객체 (배치 완료 후) */
        .text-object {
            position: absolute;
            cursor: move;
            z-index: 15;
            border: 2px solid transparent;
            white-space: pre-wrap;
            word-break: break-word;
            user-select: none;
            transition: border-color 0.15s;
            overflow: hidden;
        }
        .text-object:hover { border-color: rgba(139,92,246,0.4); }
        .text-object.selected {
            border-color: #8b5cf6;
            box-shadow: 0 0 0 1px #8b5cf6;
        }

        .text-object-actions {
            position: absolute;
            top: -30px;
            right: 0;
            display: none;
            gap: 3px;
            z-index: 16;
        }
        .text-object.selected .text-object-actions { display: flex; }

        .to-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .to-btn-edit { background: #3b82f6; color: #fff; }
        .to-btn-edit:hover { background: #60a5fa; }
        .to-btn-del { background: #ef4444; color: #fff; }
        .to-btn-del:hover { background: #f87171; }

        /* ── 하단 슬라이드 네비게이션 ── */
        .bottom-bar {
            height: 48px;
            background: #0f172a;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 0 16px;
            flex-shrink: 0;
        }

        .page-dot {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: #e2e8f0;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
        }
        .page-dot:hover { background: rgba(255,255,255,0.15); color: #ffffff; }
        .page-dot.active { background: #8b5cf6; color: #fff; }
        .page-dot.deleted { background: #ef4444; color: #fff; opacity: 0.5; }

        .page-dot-more {
            color: #94a3b8;
            font-size: 11px;
            padding: 0 4px;
        }

        /* ── 우측: 속성 패널 ── */
        .right-panel {
            width: 260px;
            background: #0f172a;
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
        }

        .right-panel::-webkit-scrollbar { width: 4px; }
        .right-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

        .rp-section {
            padding: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .rp-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #94a3b8;
            margin-bottom: 10px;
        }

        .rp-hint {
            font-size: 12px;
            color: #e2e8f0;
            line-height: 1.5;
            padding: 8px 10px;
            background: rgba(139,92,246,0.08);
            border: 1px solid rgba(139,92,246,0.15);
            border-radius: 6px;
        }

        .rp-hint strong { color: #c4b5fd; }

        /* 속성 행 */
        .rp-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            min-height: 28px;
        }

        .rp-label {
            font-size: 12px;
            color: #e2e8f0;
            flex-shrink: 0;
        }

        .rp-input {
            width: 80px;
            padding: 4px 8px;
            background: rgba(2,6,23,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            color: #ffffff;
            font-size: 12px;
            outline: none;
            font-family: inherit;
        }
        .rp-input:focus { border-color: #8b5cf6; }

        .rp-select {
            width: 130px;
            padding: 4px 6px;
            background: rgba(2,6,23,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            color: #ffffff;
            font-size: 12px;
            outline: none;
            cursor: pointer;
            font-family: inherit;
        }
        .rp-select option { background: #0f172a; }

        .rp-color {
            width: 30px;
            height: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            background: none;
            padding: 1px;
        }

        .rp-range {
            width: 80px;
            accent-color: #8b5cf6;
            height: 4px;
        }

        .rp-val {
            font-size: 11px;
            color: #94a3b8;
            min-width: 36px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .rp-btn {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.1);
            color: #ffffff;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
            text-align: center;
            margin-bottom: 6px;
        }
        .rp-btn:hover { background: rgba(255,255,255,0.15); }

        .rp-btn-danger {
            border-color: rgba(239,68,68,0.3);
            background: rgba(239,68,68,0.1);
            color: #f87171;
        }
        .rp-btn-danger:hover { background: rgba(239,68,68,0.2); }

        .rp-btn-accent {
            border: none;
            background: linear-gradient(to right, #2563eb, #9333ea);
            color: #fff;
        }
        .rp-btn-accent:hover { opacity: 0.9; }

        /* OCR 상태 */
        .ocr-bar {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(139,92,246,0.08);
            border: 1px solid rgba(139,92,246,0.15);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .ocr-bar.active { display: flex; }

        .ocr-spinner {
            width: 14px; height: 14px;
            border: 2px solid rgba(139,92,246,0.2);
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .ocr-bar span { font-size: 11px; color: #c4b5fd; }

        /* 로고 제거 섹션 */
        .logo-preview-box {
            width: 100%;
            aspect-ratio: 16/9;
            background: rgba(2,6,23,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            position: relative;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .logo-marker-vis {
            position: absolute;
            background: rgba(239,68,68,0.2);
            border: 2px dashed #f87171;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .logo-marker-vis::after {
            content: 'LOGO';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%,-50%);
            font-size: 8px;
            font-weight: 700;
            color: #f87171;
        }

        /* Processed 리스트 */
        .processed-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .processed-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 4px;
            margin-bottom: 3px;
            font-size: 11px;
        }

        .processed-dot {
            width: 6px; height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .processed-dot.done { background: #10b981; }
        .processed-dot.pending { background: #64748b; }

        /* ════════════════════════════════════════
           토스트
           ════════════════════════════════════════ */
        .toast {
            position: fixed;
            top: 56px;
            right: 16px;
            padding: 10px 16px;
            background: #0f172a;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 13px;
            color: #e2e8f0;
            z-index: 500;
            transform: translateX(calc(100% + 20px));
            transition: transform 0.25s;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
        }
        .toast.show { transform: translateX(0); }
        .toast.error { border-color: rgba(239,68,68,0.4); }
        .toast.success { border-color: rgba(16,185,129,0.4); }

        /* ════════════════════════════════════════
           모달
           ════════════════════════════════════════ */
        .modal-bg {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 400;
            align-items: center;
            justify-content: center;
        }
        .modal-bg.active { display: flex; }

        .modal-box {
            background: #0f172a;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90vw;
        }

        .modal-box h3 { font-size: 16px; color: #ffffff; margin-bottom: 10px; }
        .modal-box p { font-size: 13px; color: #94a3b8; line-height: 1.5; }

        .modal-btns {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .m-btn {
            padding: 7px 16px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.1);
            color: #e2e8f0;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
        }
        .m-btn:hover { background: rgba(255,255,255,0.15); }

        .m-btn-primary {
            background: linear-gradient(to right, #2563eb, #9333ea);
            border: none;
            color: #fff;
        }
        .m-btn-primary:hover { opacity: 0.9; }

        .m-btn-danger {
            background: #ef4444;
            border-color: #ef4444;
            color: #fff;
        }

        /* ════════════════════════════════════════
           좌측 아이콘 바
           ════════════════════════════════════════ */
        .icon-bar {
            width: 40px;
            background: #0b1120;
            border-right: 1px solid rgba(255,255,255,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 12px;
            gap: 4px;
            flex-shrink: 0;
            z-index: 30;
        }

        .icon-bar-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
        }
        .icon-bar-btn:hover { background: rgba(255,255,255,0.08); color: #e2e8f0; }
        .icon-bar-btn.active { background: rgba(139,92,246,0.2); color: #c4b5fd; }
        .icon-bar-btn svg { width: 18px; height: 18px; stroke: currentColor; fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }

        /* 좌측 오버레이 패널 */
        .left-overlay-panel {
            position: absolute;
            top: 0;
            left: 40px;
            bottom: 0;
            width: 240px;
            height: 100%;
            background: #0f172a;
            border-right: 1px solid rgba(255,255,255,0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
            box-shadow: 4px 0 16px rgba(0,0,0,0.4);
        }
        .left-overlay-panel.active { display: flex; }

        .left-overlay-header {
            padding: 14px 14px 10px;
            font-size: 13px;
            font-weight: 600;
            color: #e2e8f0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .left-overlay-close {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .left-overlay-close:hover { background: rgba(255,255,255,0.1); color: #fff; }

        .left-overlay-body {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .left-overlay-body::-webkit-scrollbar { width: 4px; }
        .left-overlay-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

        /* 레이어 아이템 */
        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.12s;
        }
        .layer-item:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.1); }
        .layer-item.selected { border-color: #8b5cf6; background: rgba(139,92,246,0.08); }

        .layer-icon {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }
        .layer-icon.text { background: rgba(59,130,246,0.2); color: #60a5fa; }
        .layer-icon.image { background: rgba(16,185,129,0.2); color: #34d399; }

        .layer-info {
            flex: 1;
            min-width: 0;
        }
        .layer-info-name {
            font-size: 12px;
            color: #e2e8f0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .layer-info-type {
            font-size: 10px;
            color: #64748b;
        }

        .layer-actions {
            display: flex;
            gap: 2px;
        }
        .layer-action-btn {
            width: 22px;
            height: 22px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }
        .layer-action-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .layer-action-btn.danger:hover { background: rgba(239,68,68,0.2); color: #f87171; }

        /* ════════════════════════════════════════
           하단 네비게이션 (화살표 + 페이지 번호)
           ════════════════════════════════════════ */
        .nav-arrow {
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            background: transparent;
            color: #e2e8f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            font-family: inherit;
        }
        .nav-arrow:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .nav-arrow:disabled { opacity: 0.3; cursor: default; }
        .nav-arrow svg { width: 16px; height: 16px; stroke: currentColor; fill: none; stroke-width: 2; }

        .nav-page-info {
            font-size: 14px;
            font-weight: 600;
            color: #e2e8f0;
            min-width: 60px;
            text-align: center;
            user-select: none;
        }
        .nav-page-info span { color: #94a3b8; font-weight: 400; }

        /* ════════════════════════════════════════
           이미지 객체
           ════════════════════════════════════════ */
        .image-object {
            position: absolute;
            cursor: move;
            z-index: 15;
            border: 2px solid transparent;
            user-select: none;
            transition: border-color 0.15s;
        }
        .image-object:hover { border-color: rgba(16,185,129,0.4); }
        .image-object.selected {
            border-color: #10b981;
            box-shadow: 0 0 0 1px #10b981;
        }

        .image-object img {
            width: 100%;
            height: 100%;
            display: block;
            pointer-events: none;
        }

        .image-object .text-object-actions { display: none; }
        .image-object.selected .text-object-actions { display: flex; }

        .image-resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #10b981;
            border: 1px solid #fff;
            border-radius: 2px;
            cursor: nwse-resize;
            z-index: 17;
        }
        .image-resize-handle.br { bottom: -5px; right: -5px; }
    </style>
</head>
<body>

    <!-- ═══ 상단 툴바 ═══ -->
    <div class="top-bar">
        <a class="logo" href="index.html" style="text-decoration:none">
            <div class="logo-icon">
                <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
            </div>
            <div>
                <span class="logo-text">NotebookLM Slide Editor</span>
                <span class="logo-sub" id="fileNameDisplay">파일을 불러오세요</span>
            </div>
        </a>

        <div class="mode-buttons">
            <button class="mode-btn" data-mode="pan" id="modePan"><kbd>Space</kbd>+ Drag</button>
            <button class="mode-btn active" data-mode="select" id="modeSelect"><kbd></kbd>Drag Selection</button>
            <button class="mode-btn" data-mode="zoom" id="modeZoom"><kbd>Ctrl</kbd>+ Wheel Zoom</button>
        </div>

        <div class="top-right">
            <button class="top-btn" id="btnOpenFile">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
                파일 열기
            </button>

            <div class="top-divider"></div>

            <button class="top-btn top-btn-delete" id="btnDeleteMode">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                페이지 삭제 모드
            </button>

            <div class="top-divider"></div>

            <button class="top-btn" id="btnLogoRemove">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>
                로고 삭제
            </button>

            <div class="top-divider"></div>

            <button class="top-btn" id="btnAddImage">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                이미지 추가
            </button>

            <div class="top-divider"></div>

            <button class="top-btn" id="btnImportPptx">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><polyline points="9 15 12 12 15 15"/></svg>
                PPTX 불러오기
            </button>

            <button class="top-btn top-btn-export" id="btnExport">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                PPTX 저장
            </button>

            <button class="top-btn top-btn-export" id="btnExportPdf">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                PDF 내보내기
            </button>
        </div>
    </div>

    <!-- ═══ 도구 모음 바 ═══ -->
    <div class="tool-bar" id="toolBar">
        <!-- 실행취소 / 다시실행 -->
        <div class="tb-group">
            <button class="tb-btn" id="tbUndo" title="실행 취소 (Ctrl+Z)">
                <svg viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
            </button>
            <button class="tb-btn" id="tbRedo" title="다시 실행 (Ctrl+Y)">
                <svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.13-9.36L23 10"/></svg>
            </button>
        </div>

        <!-- 폰트 -->
        <div class="tb-group">
            <select class="tb-select" id="tbFont" title="폰트" style="width:100px">
                <option value="'Malgun Gothic', sans-serif">맑은 고딕</option>
                <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
                <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Nanum Myeongjo', serif">나눔명조</option>
                <option value="'Gulim', sans-serif">굴림</option>
            </select>
            <input type="number" class="tb-input" id="tbFontSize" value="16" min="8" max="120" title="글자 크기">
        </div>

        <!-- 굵기/이탤릭/밑줄 -->
        <div class="tb-group">
            <button class="tb-btn" id="tbBold" title="굵게 (B)">
                <svg viewBox="0 0 24 24"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/></svg>
            </button>
            <button class="tb-btn" id="tbItalic" title="기울임 (I)">
                <svg viewBox="0 0 24 24"><line x1="19" y1="4" x2="10" y2="4"/><line x1="14" y1="20" x2="5" y2="20"/><line x1="15" y1="4" x2="9" y2="20"/></svg>
            </button>
        </div>

        <!-- 색상 -->
        <div class="tb-group">
            <span class="tb-label">글자</span>
            <input type="color" class="tb-color" id="tbColor" value="#000000" title="글자색">
            <span class="tb-label">배경</span>
            <input type="color" class="tb-color" id="tbBgColor" value="#ffffff" title="배경색">
            <button class="tb-btn" id="tbEyedrop" title="스포이드">
                <svg viewBox="0 0 24 24"><path d="M2 22l1-1h3l9-9"/><path d="M3 21v-3l9-9"/><path d="M15 6l3-3a2.12 2.12 0 0 1 3 3l-3 3"/><path d="M14.5 6.5l3 3"/></svg>
            </button>
        </div>

        <!-- 간격 -->
        <div class="tb-group">
            <span class="tb-label">자간</span>
            <input type="number" class="tb-input" id="tbLetterSp" value="0" min="-3" max="15" step="0.5" title="자간">
            <span class="tb-label">장평</span>
            <input type="number" class="tb-input" id="tbScaleX" value="100" min="60" max="140" title="장평 (%)">
            <span class="tb-label">행간</span>
            <input type="number" class="tb-input" id="tbLineH" value="140" min="80" max="250" title="행간 (%)">
        </div>

        <!-- 줌 -->
        <div class="tb-group" style="margin-left:auto">
            <button class="tb-btn" id="tbZoomOut" title="축소">
                <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
            <span class="tb-label" id="tbZoomLabel" style="min-width:36px; text-align:center; color:#e2e8f0">150%</span>
            <button class="tb-btn" id="tbZoomIn" title="확대">
                <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
            <button class="tb-btn" id="tbZoomFit" title="화면 맞춤">
                <svg viewBox="0 0 24 24"><path d="M15 3h6v6"/><path d="M9 21H3v-6"/><path d="M21 3l-7 7"/><path d="M3 21l7-7"/></svg>
            </button>
        </div>
    </div>

    <!-- 숨김 input -->
    <input type="file" id="openFileInput" accept=".pdf,.pptx" style="display:none">
    <input type="file" id="imageFileInput" accept="image/*" style="display:none">

    <!-- ═══ 메인 3단 레이아웃 ═══ -->
    <div class="editor-layout">

        <!-- 좌측 아이콘 바 -->
        <div class="icon-bar">
            <button class="icon-bar-btn" id="iconHistory" title="편집 기록">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
            </button>
            <button class="icon-bar-btn" id="iconDelete" title="슬라이드 삭제">
                <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
            </button>
            <button class="icon-bar-btn" id="iconLayers" title="레이어 관리">
                <svg viewBox="0 0 24 24"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
            </button>
        </div>

        <!-- 좌측 오버레이: 히스토리 -->
        <div class="left-overlay-panel" id="historyPanel">
            <div class="left-overlay-header">
                편집 기록
                <button class="left-overlay-close" id="closeHistory">&times;</button>
            </div>
            <div class="left-overlay-body" id="historyPanelBody">
                <div style="font-size:11px; color:#64748b; text-align:center; padding:12px 0;">편집 기록이 없습니다</div>
            </div>
        </div>

        <!-- 좌측 오버레이: 레이어 -->
        <div class="left-overlay-panel" id="layerPanel">
            <div class="left-overlay-header">
                레이어 관리
                <button class="left-overlay-close" id="closeLayer">&times;</button>
            </div>
            <div class="left-overlay-body" id="layerPanelBody">
                <div style="font-size:11px; color:#64748b; text-align:center; padding:12px 0;">편집 객체가 없습니다</div>
            </div>
        </div>

        <!-- 좌측: 슬라이드 목록 -->
        <div class="left-panel">
            <div class="left-panel-header">슬라이드 (<span id="totalPagesLabel">0</span>)</div>
            <div class="slide-list" id="slideList"></div>
        </div>

        <!-- 중앙: 캔버스 -->
        <div class="center-panel">
            <div class="canvas-viewport" id="canvasViewport">
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="mainCanvas"></canvas>
                    <div class="selection-overlay" id="selOverlay"></div>
                </div>
            </div>
        </div>

        <!-- 우측: 속성 패널 -->
        <div class="right-panel" id="rightPanel">

            <!-- 텍스트 편집 헤더 -->
            <div class="rp-section" style="border-bottom:none; padding-bottom:4px;">
                <div style="display:flex; align-items:center; gap:8px; font-size:15px; font-weight:600; color:#c4b5fd;">
                    <span style="font-size:18px;">T</span> 새 텍스트 추가
                </div>
            </div>

            <!-- AI 분석 버튼 -->
            <div class="rp-section" id="sectionAiBtn" style="padding-top:0;">
                <button class="rp-btn" id="btnAiAnalyze" style="background:linear-gradient(to right,#7c3aed,#6d28d9); border:none; color:#fff; padding:12px; font-size:13px; font-weight:600; display:flex; align-items:center; justify-content:center; gap:8px; opacity:0.5; cursor:not-allowed;" disabled>
                    <span style="font-size:16px;">&#10024;</span> AI 텍스트 분석 실행
                </button>
                <div id="aiHint" style="font-size:11px; color:#64748b; text-align:center; margin-top:6px;">
                    Drag Selection 모드에서 텍스트 영역을 드래그하세요
                </div>
            </div>

            <!-- OCR 상태 -->
            <div class="rp-section" style="padding-top:0; padding-bottom:8px; border:none; display:none;" id="sectionOcr">
                <div class="ocr-bar active" id="ocrBar">
                    <div class="ocr-spinner"></div>
                    <span id="ocrText">OCR 분석 중...</span>
                </div>
            </div>

            <!-- 인식 결과 & 편집 영역 (선택 후 표시) -->
            <div id="sectionEditArea" style="display:none;">

                <!-- 인식된 텍스트 -->
                <div class="rp-section" style="padding-bottom:8px;">
                    <div class="rp-title">인식된 텍스트</div>
                    <div id="recognizedText" style="font-size:12px; color:#94a3b8; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.05); border-radius:6px; padding:8px; max-height:60px; overflow-y:auto; word-break:break-all;"></div>
                </div>

                <!-- 내용 편집 -->
                <div class="rp-section" style="padding-top:4px; padding-bottom:8px;">
                    <div class="rp-title">내용</div>
                    <textarea id="propContent" style="width:100%; height:80px; background:rgba(2,6,23,0.5); border:1px solid rgba(255,255,255,0.1); border-radius:6px; color:#ffffff; font-size:13px; padding:8px; resize:vertical; outline:none; font-family:inherit; line-height:1.5;" placeholder="텍스트 입력..."></textarea>
                </div>

                <!-- 폰트 패밀리 -->
                <div class="rp-section" style="padding-top:4px; padding-bottom:8px;">
                    <div class="rp-title">폰트 패밀리</div>
                    <select class="rp-select" id="propFont" style="width:100%;">
                        <option value="'Malgun Gothic', sans-serif">맑은 고딕</option>
                        <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
                        <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="'Nanum Myeongjo', serif">나눔명조</option>
                        <option value="'Gulim', sans-serif">굴림</option>
                    </select>
                </div>

                <!-- 폰트 크기 & 스타일 -->
                <div class="rp-section" style="padding-top:4px; padding-bottom:8px;">
                    <div style="display:flex; gap:16px;">
                        <div style="flex:1;">
                            <div class="rp-title">폰트 크기</div>
                            <input type="number" class="rp-input" id="propSize" value="16" min="8" max="120" style="width:100%;">
                        </div>
                        <div>
                            <div class="rp-title">스타일</div>
                            <div style="display:flex; gap:4px;">
                                <button class="tb-btn" id="propBoldBtn" style="width:36px; height:32px; border:1px solid rgba(255,255,255,0.1); border-radius:6px; font-weight:900; font-size:14px;">B</button>
                                <button class="tb-btn" id="propItalicBtn" style="width:36px; height:32px; border:1px solid rgba(255,255,255,0.1); border-radius:6px; font-style:italic; font-size:14px;">I</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 글자 색상 & 배경 색상 -->
                <div class="rp-section" style="padding-top:4px; padding-bottom:8px;">
                    <div style="display:flex; gap:16px;">
                        <div style="flex:1;">
                            <div class="rp-title">글자 색상</div>
                            <div style="display:flex; align-items:center; gap:4px;">
                                <input type="text" id="propColorHex" value="#000000" style="flex:1; padding:4px 6px; background:rgba(2,6,23,0.5); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff; font-size:11px; font-family:monospace; outline:none;">
                                <input type="color" class="rp-color" id="propColor" value="#000000">
                            </div>
                        </div>
                        <div style="flex:1;">
                            <div class="rp-title">배경 색상</div>
                            <div style="display:flex; align-items:center; gap:4px;">
                                <input type="text" id="propBgColorHex" value="#ffffff" style="flex:1; padding:4px 6px; background:rgba(2,6,23,0.5); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff; font-size:11px; font-family:monospace; outline:none;">
                                <input type="color" class="rp-color" id="propBgColor" value="#ffffff">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 고급 설정 -->
                <div class="rp-section" style="padding-top:4px; padding-bottom:8px;">
                    <div class="rp-title">고급 설정</div>
                    <div style="display:flex; gap:16px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <div style="font-size:10px; color:#64748b; margin-bottom:4px;">줄 간격</div>
                            <input type="number" class="rp-input" id="propLineH" value="1.4" min="0.8" max="3" step="0.1" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:10px; color:#64748b; margin-bottom:4px;">자간 (PX)</div>
                            <input type="number" class="rp-input" id="propLetterSp" value="0" min="-3" max="15" step="0.5" style="width:100%;">
                        </div>
                    </div>
                    <div>
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                            <span style="font-size:10px; color:#64748b;">장평 (%)</span>
                            <span style="font-size:12px; color:#8b5cf6; font-weight:600;" id="valScaleX">100%</span>
                        </div>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <input type="range" id="propScaleX" min="60" max="140" value="100" style="flex:1; accent-color:#8b5cf6; height:4px;">
                            <input type="number" class="rp-input" id="propScaleXNum" value="100" min="60" max="140" style="width:56px;">
                        </div>
                    </div>
                    <div style="margin-top:8px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                            <span style="font-size:10px; color:#64748b;">여백 (PX)</span>
                            <span style="font-size:11px; color:#94a3b8;" id="valPad">4px</span>
                        </div>
                        <input type="range" id="propPad" min="0" max="20" value="4" style="width:100%; accent-color:#8b5cf6; height:4px;">
                    </div>
                </div>

                <!-- 변경 사항 적용 버튼 (하단 고정) -->
                <div style="padding:14px; position:sticky; bottom:0; background:#0f172a; border-top:1px solid rgba(255,255,255,0.05);">
                    <button id="btnApplyChanges" style="width:100%; padding:14px; border-radius:8px; border:none; background:linear-gradient(to right,#10b981,#14b8a6); color:#fff; font-size:14px; font-weight:700; cursor:pointer; display:flex; align-items:center; justify-content:center; gap:8px; transition:opacity 0.15s; font-family:inherit;">
                        <span style="font-size:16px;">&#10003;</span> 변경 사항 적용
                    </button>
                </div>
            </div>

            <!-- 로고 삭제 설정 -->
            <div class="rp-section" id="sectionLogo" style="display:none">
                <div class="rp-title">로고 삭제</div>
                <div class="logo-preview-box" id="logoPreviewBox">
                    <div class="logo-marker-vis" id="logoMarkerVis"></div>
                </div>
                <div class="rp-row">
                    <span class="rp-label">위치</span>
                    <select class="rp-select" id="logoPos" style="width:110px">
                        <option value="bottom-right" selected>우측 하단</option>
                        <option value="bottom-left">좌측 하단</option>
                        <option value="top-right">우측 상단</option>
                        <option value="top-left">좌측 상단</option>
                    </select>
                </div>
                <div class="rp-row">
                    <span class="rp-label">너비</span>
                    <input type="range" class="rp-range" id="logoW" min="30" max="300" value="140">
                    <span class="rp-val" id="valLogoW">140</span>
                </div>
                <div class="rp-row">
                    <span class="rp-label">높이</span>
                    <input type="range" class="rp-range" id="logoH" min="15" max="150" value="40">
                    <span class="rp-val" id="valLogoH">40</span>
                </div>
                <button class="rp-btn rp-btn-danger" id="btnLogoAllRemove" style="margin-top:6px;">모든 슬라이드 로고 삭제</button>
                <button class="rp-btn" id="btnLogoOneRemove">현재 슬라이드만 삭제</button>
            </div>

        </div>
    </div>

    <!-- ═══ 하단 슬라이드 번호 ═══ -->
    <div class="bottom-bar" id="bottomBar"></div>

    <!-- 모달 -->
    <div class="modal-bg" id="exportModal">
        <div class="modal-box">
            <h3>PPTX로 내보내기</h3>
            <p>편집된 슬라이드를 PowerPoint(.pptx) 파일로 저장합니다.</p>
            <div id="exportProgress" style="display:none; margin-top:12px;">
                <div style="background:#21262d; border-radius:4px; height:6px; overflow:hidden;">
                    <div id="exportProgressBar" style="background:linear-gradient(90deg,#586efa,#7c3aed); height:100%; width:0%; transition:width 0.3s;"></div>
                </div>
                <p style="font-size:11px; color:#7d8590; margin-top:6px;" id="exportProgressText">준비 중...</p>
            </div>
            <div class="modal-btns" id="exportBtns">
                <button class="m-btn" id="exportCancel">취소</button>
                <button class="m-btn m-btn-primary" id="exportAll">전체 슬라이드 PPTX</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ═══════════════════════════════
    //  PDF 데이터 로드 (IndexedDB 우선 + localStorage 폴백)
    // ═══════════════════════════════
    const DB_NAME = 'PdfSlideEditorDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'pdfFiles';

    function openDB() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }

    async function loadPdfFromIndexedDB() {
        try {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const req = tx.objectStore(STORE_NAME).get('pdf_data');
                req.onsuccess = () => { db.close(); resolve(req.result || null); };
                req.onerror = () => { db.close(); resolve(null); };
            });
        } catch(e) { return null; }
    }

    function loadPdfFromLocalStorage() {
        const chunkCount = parseInt(localStorage.getItem('pdf_chunks') || '0');
        if (chunkCount === 0) return null;
        let base64 = '';
        for (let i = 0; i < chunkCount; i++) {
            const chunk = localStorage.getItem('pdf_chunk_' + i);
            if (!chunk) return null;
            base64 += chunk;
        }
        const binary = atob(base64);
        const buf = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) buf[i] = binary.charCodeAt(i);
        return buf.buffer;
    }

    async function loadPdfFromStorage() {
        // IndexedDB 우선 시도
        const idbData = await loadPdfFromIndexedDB();
        if (idbData) return idbData;
        // localStorage 폴백
        return loadPdfFromLocalStorage();
    }

    // ═══════════════════════════════
    //  STATE
    // ═══════════════════════════════
    const S = {
        pdfDoc: null,
        currentPage: 1,
        totalPages: 0,
        scale: 1,             // 초기값 (로드 시 calcFitScale로 자동 조정)
        mode: 'pan',          // pan | select | zoom
        deleteMode: false,
        deletedPages: new Set(),
        editLayers: {},        // page -> [{bgColor, text, rect, styles, padding}]
        originals: {},         // page -> ImageData
        isSelecting: false,
        selStart: null,
        selEnd: null,
        eyedropActive: false,
        logoVisible: false,
        // pan state
        isPanning: false,
        panStart: null,
        panScroll: null,
        spaceHeld: false,
        prevMode: null,
        selectedObject: null,
        textItems: {},         // page -> { items, styles, viewport }
        imageLayers: {}        // page -> [{type, src, name, x, y, w, h}]
    };

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('selOverlay');
    const container = document.getElementById('canvasContainer');

    // ═══════════════════════════════
    //  INIT
    // ═══════════════════════════════
    function loadImg(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    }

    async function loadSlideImagesFromDB() {
        try {
            const db = await openDB();
            return new Promise((resolve) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const req = tx.objectStore(STORE_NAME).get('slide_images');
                req.onsuccess = () => { db.close(); resolve(req.result || null); };
                req.onerror = () => { db.close(); resolve(null); };
            });
        } catch(e) { return null; }
    }

    async function init() {
        const sourceType = localStorage.getItem('pdf_type') || 'pdf';
        const pdfName = localStorage.getItem('pdf_fileName') || '';

        if (sourceType === 'pptx') {
            // PPTX 이미지 모드
            const slides = await loadSlideImagesFromDB();
            if (!slides || slides.length === 0) {
                showToast('슬라이드 데이터를 찾을 수 없습니다.', 'error');
                setTimeout(() => { window.location.href = 'index.html'; }, 2000);
                return;
            }
            S.slideImages = slides;
            S.totalPages = slides.length;
            document.getElementById('fileNameDisplay').textContent = pdfName;
            document.getElementById('totalPagesLabel').textContent = S.totalPages;
            S.currentPage = 1;
            S.editLayers = {};
            S.imageLayers = {};
            S.originals = {};
            S.deletedPages.clear();
            buildThumbs();
            buildBottomBar();
            await renderPage(1);
            updateZoomLabel();
            showToast(`${pdfName} 로드 완료 (${S.totalPages}페이지)`, 'success');
        } else {
            // PDF 모드
            const arrayBuffer = await loadPdfFromStorage();
            if (!arrayBuffer) {
                showToast('PDF 파일이 없습니다. 메인으로 돌아가세요.', 'error');
                setTimeout(() => { window.location.href = 'index.html'; }, 2000);
                return;
            }
            await loadPdf(arrayBuffer, pdfName);
        }
    }

    async function loadPdf(arrayBuffer, pdfName) {
        document.getElementById('fileNameDisplay').textContent = pdfName || '';

        const u8 = new Uint8Array(arrayBuffer);
        S.pdfDoc = await pdfjsLib.getDocument({ data: u8 }).promise;
        S.totalPages = S.pdfDoc.numPages;
        document.getElementById('totalPagesLabel').textContent = S.totalPages;

        // 상태 초기화
        S.currentPage = 1;
        S.editLayers = {};
        S.imageLayers = {};
        S.originals = {};
        S.deletedPages.clear();

        buildThumbs();
        buildBottomBar();

        // 첫 페이지 크기 기반으로 뷰포트에 딱 맞는 줌 계산
        const firstPage = await S.pdfDoc.getPage(1);
        S.scale = await calcFitScale(firstPage);

        await renderPage(1);
        updateZoomLabel();
        showToast(`${pdfName || 'PDF'} 로드 완료 (${S.totalPages}페이지)`, 'success');
    }

    // ═══════════════════════════════
    //  THUMBNAILS
    // ═══════════════════════════════
    function buildThumbs() {
        const list = document.getElementById('slideList');
        list.innerHTML = '';
        for (let i = 1; i <= S.totalPages; i++) {
            const div = document.createElement('div');
            div.className = 'slide-thumb' + (i === 1 ? ' active' : '');
            div.dataset.page = i;

            const c = document.createElement('canvas');
            div.appendChild(c);

            const num = document.createElement('span');
            num.className = 'slide-thumb-num';
            num.textContent = i;
            div.appendChild(num);

            div.addEventListener('click', () => {
                if (S.deleteMode) {
                    toggleDeletePage(i, div);
                    return;
                }
                document.querySelectorAll('.slide-thumb').forEach(t => t.classList.remove('active'));
                div.classList.add('active');
                renderPage(i);
            });

            list.appendChild(div);
            renderThumb(i, c);
        }
    }

    async function renderThumb(p, tc) {
        if (S.pdfDoc) {
            const page = await S.pdfDoc.getPage(p);
            const vp = page.getViewport({ scale: 0.25 });
            tc.width = vp.width;
            tc.height = vp.height;
            await page.render({ canvasContext: tc.getContext('2d'), viewport: vp }).promise;
        } else if (S.slideImages) {
            const img = await loadImg(S.slideImages[p - 1]);
            tc.width = Math.round(img.width * 0.12);
            tc.height = Math.round(img.height * 0.12);
            tc.getContext('2d').drawImage(img, 0, 0, tc.width, tc.height);
        }
    }

    // ═══════════════════════════════
    //  BOTTOM BAR
    // ═══════════════════════════════
    function buildBottomBar() {
        const bar = document.getElementById('bottomBar');
        bar.innerHTML = '';

        const prevBtn = document.createElement('button');
        prevBtn.className = 'nav-arrow';
        prevBtn.id = 'navPrev';
        prevBtn.innerHTML = '<svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"/></svg>';
        prevBtn.addEventListener('click', () => {
            if (S.currentPage > 1) renderPage(S.currentPage - 1);
        });

        const pageInfo = document.createElement('span');
        pageInfo.className = 'nav-page-info';
        pageInfo.id = 'navPageInfo';
        pageInfo.innerHTML = `${S.currentPage} <span>/ ${S.totalPages}</span>`;

        const nextBtn = document.createElement('button');
        nextBtn.className = 'nav-arrow';
        nextBtn.id = 'navNext';
        nextBtn.innerHTML = '<svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>';
        nextBtn.addEventListener('click', () => {
            if (S.currentPage < S.totalPages) renderPage(S.currentPage + 1);
        });

        bar.appendChild(prevBtn);
        bar.appendChild(pageInfo);
        bar.appendChild(nextBtn);
        updateBottomBar();
    }

    function updateBottomBar() {
        const info = document.getElementById('navPageInfo');
        if (info) info.innerHTML = `${S.currentPage} <span>/ ${S.totalPages}</span>`;
        const prev = document.getElementById('navPrev');
        const next = document.getElementById('navNext');
        if (prev) prev.disabled = S.currentPage <= 1;
        if (next) next.disabled = S.currentPage >= S.totalPages;
    }

    // ═══════════════════════════════
    //  RENDER PAGE
    // ═══════════════════════════════
    async function renderPage(p) {
        S.currentPage = p;
        S.selectedObject = null;
        container.querySelectorAll('.text-object').forEach(el => el.remove());
        container.querySelectorAll('.image-object').forEach(el => el.remove());

        if (S.pdfDoc) {
            const page = await S.pdfDoc.getPage(p);
            const vp = page.getViewport({ scale: S.scale });
            canvas.width = vp.width;
            canvas.height = vp.height;
            await page.render({ canvasContext: ctx, viewport: vp }).promise;

            // pdf.js 텍스트 메타데이터 캐시 (원본 속성 감지용)
            if (!S.textItems[p]) {
                const textContent = await page.getTextContent();
                S.textItems[p] = {
                    items: textContent.items,
                    styles: textContent.styles,
                    viewport: vp
                };
            }
        } else if (S.slideImages) {
            const img = await loadImg(S.slideImages[p - 1]);
            const ratio = S.scale / 2.0;
            canvas.width = Math.round(img.width * ratio);
            canvas.height = Math.round(img.height * ratio);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        if (!S.originals[p]) {
            S.originals[p] = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        reapplyEdits(p);

        document.querySelectorAll('.slide-thumb').forEach(t => {
            t.classList.toggle('active', parseInt(t.dataset.page) === p);
        });
        updateBottomBar();

        // 이미지 객체 복원
        if (S.imageLayers && S.imageLayers[p]) {
            S.imageLayers[p].forEach(data => createImageObject(data));
        }

        // 레이어 패널 갱신
        if (typeof activeLeftPanel !== 'undefined' && activeLeftPanel === 'layerPanel') {
            refreshLayerPanel();
        }
    }

    function reapplyEdits(p) {
        (S.editLayers[p] || []).forEach(l => {
            paintEditOnCanvas(l);
        });
    }

    function paintEditOnCanvas(l) {
        ctx.fillStyle = l.bgColor;
        ctx.fillRect(l.rect.x - l.padding, l.rect.y - l.padding, l.rect.w + l.padding * 2, l.rect.h + l.padding * 2);
        ctx.save();
        ctx.fillStyle = l.styles.color;
        ctx.font = `${l.styles.fontWeight} ${l.styles.fontSize}px ${l.styles.font}`;
        ctx.textBaseline = 'top';
        const lineH = l.styles.fontSize * l.styles.lineHeight;
        let ty = l.rect.y + 2;
        l.text.split('\n').forEach(line => {
            if (l.styles.letterSpacing !== 0 || l.styles.scaleX !== 1) {
                ctx.save();
                ctx.translate(l.rect.x + 2, ty);
                ctx.scale(l.styles.scaleX, 1);
                let tx = 0;
                for (const ch of line) {
                    ctx.fillText(ch, tx, 0);
                    tx += ctx.measureText(ch).width + l.styles.letterSpacing;
                }
                ctx.restore();
            } else {
                ctx.fillText(line, l.rect.x + 2, ty);
            }
            ty += lineH;
        });
        ctx.restore();
    }

    // 텍스트 객체를 DOM 요소로 생성
    function createTextObject(data) {
        const div = document.createElement('div');
        div.className = 'text-object';
        div.style.left = (data.rect.x - data.padding) + 'px';
        div.style.top = (data.rect.y - data.padding) + 'px';
        div.style.width = (data.rect.w + data.padding * 2) + 'px';
        div.style.height = (data.rect.h + data.padding * 2) + 'px';
        div.style.backgroundColor = data.bgColor;
        div.style.padding = data.padding + 'px';
        div.style.fontFamily = data.styles.font;
        div.style.fontSize = data.styles.fontSize + 'px';
        div.style.fontWeight = data.styles.fontWeight;
        div.style.color = data.styles.color;
        div.style.letterSpacing = data.styles.letterSpacing + 'px';
        div.style.transform = `scaleX(${data.styles.scaleX})`;
        div.style.transformOrigin = 'left top';
        div.style.lineHeight = data.styles.lineHeight;
        div.textContent = data.text;

        // 액션 버튼
        const actions = document.createElement('div');
        actions.className = 'text-object-actions';

        const btnEdit = document.createElement('button');
        btnEdit.className = 'to-btn to-btn-edit';
        btnEdit.innerHTML = '&#9998;';
        btnEdit.title = '편집';

        const btnDel = document.createElement('button');
        btnDel.className = 'to-btn to-btn-del';
        btnDel.innerHTML = '&#10005;';
        btnDel.title = '삭제';

        actions.appendChild(btnEdit);
        actions.appendChild(btnDel);
        div.appendChild(actions);

        // 데이터 참조 저장
        div._editData = data;

        // 클릭 → 선택
        div.addEventListener('mousedown', (e) => {
            if (S.mode !== 'select') return;
            e.stopPropagation();
            selectTextObject(div);
            // 드래그 이동 시작
            const startX = e.clientX;
            const startY = e.clientY;
            const origLeft = parseInt(div.style.left);
            const origTop = parseInt(div.style.top);

            function onMove(ev) {
                const dx = ev.clientX - startX;
                const dy = ev.clientY - startY;
                div.style.left = (origLeft + dx) + 'px';
                div.style.top = (origTop + dy) + 'px';
            }
            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                // 데이터 업데이트
                data.rect.x = parseInt(div.style.left) + data.padding;
                data.rect.y = parseInt(div.style.top) + data.padding;
            }
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });

        // 더블클릭 → 재편집
        div.addEventListener('dblclick', (e) => {
            if (S.mode !== 'select') return;
            e.stopPropagation();
            reopenEdit(div, data);
        });

        // 삭제 버튼
        btnDel.addEventListener('click', (e) => {
            e.stopPropagation();
            removeTextObject(div);
        });

        // 편집 버튼
        btnEdit.addEventListener('click', (e) => {
            e.stopPropagation();
            reopenEdit(div, data);
        });

        container.appendChild(div);
        return div;
    }

    function selectTextObject(div) {
        // 이전 선택 해제
        container.querySelectorAll('.text-object.selected').forEach(el => el.classList.remove('selected'));
        div.classList.add('selected');
        S.selectedObject = div;
    }

    function removeTextObject(div) {
        const data = div._editData;
        const layers = S.editLayers[S.currentPage];
        if (layers) {
            const idx = layers.indexOf(data);
            if (idx !== -1) layers.splice(idx, 1);
        }
        div.remove();
        S.selectedObject = null;
        updateThumbFromSource(S.currentPage);
        addProcessed(`슬라이드 ${S.currentPage} 텍스트 삭제`);
        showToast('텍스트 객체 삭제됨', 'success');
    }

    function reopenEdit(div, data) {
        // 기존 텍스트 객체를 편집 레이어로 변환 → 우측 패널에서 재편집
        div.remove();
        const layers = S.editLayers[S.currentPage];
        if (layers) {
            const idx = layers.indexOf(data);
            if (idx !== -1) layers.splice(idx, 1);
        }
        S.selectedObject = null;

        // 우측 패널 속성 복원
        document.getElementById('propFont').value = data.styles.font;
        document.getElementById('propSize').value = data.styles.fontSize;
        const isBold = data.styles.fontWeight >= 600;
        document.getElementById('propBoldBtn').classList.toggle('active', isBold);
        document.getElementById('tbBold').classList.toggle('active', isBold);
        document.getElementById('propColor').value = data.styles.color;
        document.getElementById('propColorHex').value = data.styles.color;
        document.getElementById('propLetterSp').value = data.styles.letterSpacing;
        document.getElementById('propScaleX').value = Math.round(data.styles.scaleX * 100);
        document.getElementById('propScaleXNum').value = Math.round(data.styles.scaleX * 100);
        document.getElementById('valScaleX').textContent = Math.round(data.styles.scaleX * 100) + '%';
        document.getElementById('propLineH').value = data.styles.lineHeight;
        document.getElementById('propBgColor').value = data.bgColor;
        document.getElementById('propBgColorHex').value = data.bgColor;
        document.getElementById('propPad').value = data.padding;

        // pendingRect 설정 및 우측 패널 활성화
        S.pendingRect = {...data.rect};
        document.getElementById('recognizedText').textContent = data.text;
        document.getElementById('propContent').value = data.text;
        document.getElementById('sectionEditArea').style.display = 'block';
        const btn = document.getElementById('btnAiAnalyze');
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';

        updateThumbFromSource(S.currentPage);
    }

    // 캔버스 밖 클릭 시 선택 해제
    overlay.addEventListener('mousedown', (e) => {
        if (S.selectedObject && S.mode === 'select') {
            S.selectedObject.classList.remove('selected');
            S.selectedObject = null;
        }
    }, true);

    // 텍스트 객체를 캔버스에 그리기 (내보내기용)
    function renderEditsToCanvas(p) {
        (S.editLayers[p] || []).forEach(l => {
            ctx.fillStyle = l.bgColor;
            ctx.fillRect(l.rect.x - l.padding, l.rect.y - l.padding, l.rect.w + l.padding * 2, l.rect.h + l.padding * 2);
            ctx.save();
            ctx.fillStyle = l.styles.color;
            ctx.font = `${l.styles.fontWeight} ${l.styles.fontSize}px ${l.styles.font}`;
            ctx.textBaseline = 'top';
            const lineH = l.styles.fontSize * l.styles.lineHeight;
            let ty = l.rect.y + 2;
            l.text.split('\n').forEach(line => {
                if (l.styles.letterSpacing !== 0 || l.styles.scaleX !== 1) {
                    ctx.save();
                    ctx.translate(l.rect.x + 2, ty);
                    ctx.scale(l.styles.scaleX, 1);
                    let tx = 0;
                    for (const ch of line) {
                        ctx.fillText(ch, tx, 0);
                        tx += ctx.measureText(ch).width + l.styles.letterSpacing;
                    }
                    ctx.restore();
                } else {
                    ctx.fillText(line, l.rect.x + 2, ty);
                }
                ty += lineH;
            });
            ctx.restore();
        });
    }

    // ═══════════════════════════════
    //  MODES
    // ═══════════════════════════════
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => switchMode(btn.dataset.mode));
    });

    // 줌 (Ctrl + Wheel)
    const viewport = document.getElementById('canvasViewport');
    viewport.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            S.scale = Math.max(0.5, Math.min(4, S.scale + delta));
            renderPage(S.currentPage);
        }
    }, { passive: false });

    // ═══════════════════════════════
    //  PAN (Space + Drag)
    // ═══════════════════════════════
    function switchMode(mode) {
        S.mode = mode;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
        overlay.className = 'selection-overlay';
        if (mode === 'pan') overlay.classList.add('pan-mode');
        if (S.deleteMode) overlay.classList.add('delete-mode');
    }

    // Space 키 누르면 임시 팬 모드
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !S.spaceHeld && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            S.spaceHeld = true;
            S.prevMode = S.mode;
            switchMode('pan');
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && S.spaceHeld) {
            e.preventDefault();
            S.spaceHeld = false;
            if (S.prevMode) {
                switchMode(S.prevMode);
                S.prevMode = null;
            }
        }
    });

    // 팬 드래그 동작
    overlay.addEventListener('mousedown', (e) => {
        if (S.mode === 'pan' && !S.eyedropActive) {
            S.isPanning = true;
            S.panStart = { x: e.clientX, y: e.clientY };
            S.panScroll = { x: viewport.scrollLeft, y: viewport.scrollTop };
            overlay.style.cursor = 'grabbing';
            e.preventDefault();
            return;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (S.isPanning) {
            const dx = e.clientX - S.panStart.x;
            const dy = e.clientY - S.panStart.y;
            viewport.scrollLeft = S.panScroll.x - dx;
            viewport.scrollTop = S.panScroll.y - dy;
            return;
        }
    });

    document.addEventListener('mouseup', () => {
        if (S.isPanning) {
            S.isPanning = false;
            overlay.style.cursor = '';
            if (S.mode === 'pan') overlay.style.cursor = 'grab';
        }
    });

    // ═══════════════════════════════
    //  TEXT PROPERTY DETECTION (pdf.js 원본 속성 감지)
    // ═══════════════════════════════

    // pdf.js 폰트명 → 에디터 폰트 옵션 매핑
    const FONT_MAP = [
        { patterns: ['malgun', 'gothic', 'g_d_'], value: "'Malgun Gothic', sans-serif" },
        { patterns: ['nanum', 'nanumgothic'], value: "'Nanum Gothic', sans-serif" },
        { patterns: ['notosans', 'noto'], value: "'Noto Sans KR', sans-serif" },
        { patterns: ['arial', 'helvetica'], value: "Arial, sans-serif" },
        { patterns: ['nanummyeongjo', 'myeongjo', 'batang'], value: "'Nanum Myeongjo', serif" },
        { patterns: ['gulim'], value: "'Gulim', sans-serif" }
    ];

    function mapPdfFont(pdfFontName) {
        const lower = (pdfFontName || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        for (const entry of FONT_MAP) {
            if (entry.patterns.some(p => lower.includes(p))) return entry.value;
        }
        return "'Malgun Gothic', sans-serif";
    }

    function findTextItemsInRect(rect) {
        const data = S.textItems[S.currentPage];
        if (!data) return null;

        const vp = data.viewport;
        const matched = [];

        for (const item of data.items) {
            if (!item.str || !item.str.trim()) continue;
            const tx = item.transform;
            // pdf.js transform: [scaleX, skewY, skewX, scaleY, translateX, translateY]
            // viewport 변환으로 캔버스 좌표 계산
            const pdfFontSize = Math.hypot(tx[0], tx[1]);
            const [cx, cy] = vp.convertToViewportPoint(tx[4], tx[5]);
            const itemW = item.width * vp.scale;
            const itemH = pdfFontSize * vp.scale;

            // 사각형 겹침 검사
            if (cx < rect.x + rect.w && cx + itemW > rect.x &&
                cy - itemH < rect.y + rect.h && cy > rect.y) {
                matched.push({
                    str: item.str,
                    x: cx, y: cy - itemH,
                    w: itemW, h: itemH,
                    pdfFontSize: pdfFontSize,  // PDF 원본 단위 (스케일 미적용)
                    fontName: item.fontName,
                    fontFamily: data.styles[item.fontName]?.fontFamily || ''
                });
            }
        }

        if (matched.length === 0) return null;

        // 가장 많이 사용된 폰트 크기 / 폰트 패밀리 추출
        const sizeCounts = {};
        const fontCounts = {};
        matched.forEach(m => {
            const sKey = Math.round(m.pdfFontSize);
            sizeCounts[sKey] = (sizeCounts[sKey] || 0) + m.str.length;
            const fKey = m.fontName;
            fontCounts[fKey] = (fontCounts[fKey] || 0) + m.str.length;
        });

        let dominantPdfSize = 16, maxSizeCount = 0;
        for (const [s, c] of Object.entries(sizeCounts)) {
            if (c > maxSizeCount) { maxSizeCount = c; dominantPdfSize = parseInt(s); }
        }

        let dominantFontName = '', maxFontCount = 0;
        for (const [f, c] of Object.entries(fontCounts)) {
            if (c > maxFontCount) { maxFontCount = c; dominantFontName = f; }
        }

        const fontFamily = data.styles[dominantFontName]?.fontFamily || '';
        const isBold = dominantFontName.toLowerCase().includes('bold') ||
                       fontFamily.toLowerCase().includes('bold');

        // 캔버스 좌표에서의 실제 표시 크기 = pdfFontSize * vp.scale
        // DOM 텍스트 객체는 canvas-container 안에서 동일 좌표계 사용
        const canvasFontSize = dominantPdfSize * vp.scale;

        // 선택 영역 높이 기반 sanity check: 폰트가 선택 영역보다 크면 안 됨
        const maxReasonable = rect.h * 0.95;
        const finalSize = Math.min(canvasFontSize, maxReasonable);

        return {
            fontSize: Math.round(finalSize),
            fontFamily: mapPdfFont(fontFamily || dominantFontName),
            fontWeight: isBold ? '700' : '400'
        };
    }

    function detectTextColor(rect, bgColorHex) {
        const img = ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
        // 배경색 RGB 파싱
        const bgR = parseInt(bgColorHex.slice(1, 3), 16);
        const bgG = parseInt(bgColorHex.slice(3, 5), 16);
        const bgB = parseInt(bgColorHex.slice(5, 7), 16);

        // 배경색과 충분히 다른 픽셀들의 색상 빈도 분석
        const colors = {};
        for (let i = 0; i < img.data.length; i += 4) {
            const r = img.data[i], g = img.data[i + 1], b = img.data[i + 2];
            // 배경색과의 거리 계산
            const dist = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
            if (dist < 60) continue; // 배경색에 가까운 픽셀 무시
            const k = `${Math.round(r / 8) * 8},${Math.round(g / 8) * 8},${Math.round(b / 8) * 8}`;
            colors[k] = (colors[k] || 0) + 1;
        }

        let mk = '', mc = 0;
        for (const [k, v] of Object.entries(colors)) {
            if (v > mc) { mc = v; mk = k; }
        }

        if (!mk) return '#000000'; // 텍스트 색상 미감지 시 기본 검정
        const [r, g, b] = mk.split(',').map(Number);
        return rgbHex(r, g, b);
    }

    function applyDetectedProps(rect, bgColorHex) {
        const textColor = detectTextColor(rect, bgColorHex);
        document.getElementById('propColor').value = textColor;
        document.getElementById('propColorHex').value = textColor;
        document.getElementById('tbColor').value = textColor;

        const props = findTextItemsInRect(rect);
        if (props) {
            document.getElementById('propSize').value = props.fontSize;
            document.getElementById('tbFontSize').value = props.fontSize;
            document.getElementById('propFont').value = props.fontFamily;
            document.getElementById('tbFont').value = props.fontFamily;
            const isBold = props.fontWeight >= 600;
            document.getElementById('propBoldBtn').classList.toggle('active', isBold);
            document.getElementById('tbBold').classList.toggle('active', isBold);
        }

        // 배경색 hex 동기화
        document.getElementById('propBgColorHex').value = bgColorHex;
    }

    // ═══════════════════════════════
    //  SELECTION (드래그 → 선택 박스 유지 → AI 버튼 활성화)
    // ═══════════════════════════════
    overlay.addEventListener('mousedown', (e) => {
        if (S.mode !== 'select' || S.deleteMode || S.eyedropActive) return;
        clearSelBox();
        S.pendingRect = null;
        const r = overlay.getBoundingClientRect();
        S.isSelecting = true;
        S.selStart = { x: e.clientX - r.left, y: e.clientY - r.top };
    });

    overlay.addEventListener('mousemove', (e) => {
        if (!S.isSelecting) return;
        const r = overlay.getBoundingClientRect();
        S.selEnd = { x: e.clientX - r.left, y: e.clientY - r.top };
        drawSelBox();
    });

    overlay.addEventListener('mouseup', (e) => {
        if (!S.isSelecting) return;
        S.isSelecting = false;
        const r = overlay.getBoundingClientRect();
        S.selEnd = { x: e.clientX - r.left, y: e.clientY - r.top };
        const rect = getSelRect();
        if (rect.w > 10 && rect.h > 10) {
            // 선택 박스 유지, 배경색 감지
            S.pendingRect = rect;
            detectBg(rect);
            // AI 분석 버튼 활성화
            const btn = document.getElementById('btnAiAnalyze');
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            document.getElementById('aiHint').textContent = '영역 선택 완료 — AI 분석 버튼을 클릭하세요';
            document.getElementById('aiHint').style.color = '#10b981';
        } else {
            // 클릭 — 자동 텍스트 영역 감지
            clearSelBox();
            const cx = Math.round(S.selStart.x);
            const cy = Math.round(S.selStart.y);
            const autoRect = autoDetectTextRegion(cx, cy);
            if (autoRect) {
                detectBg(autoRect);
                runOCR(autoRect);
            }
        }
    });

    // 스포이드
    overlay.addEventListener('click', (e) => {
        if (!S.eyedropActive) return;
        const r = overlay.getBoundingClientRect();
        const px = ctx.getImageData(e.clientX - r.left, e.clientY - r.top, 1, 1).data;
        const hex = rgbHex(px[0], px[1], px[2]);
        document.getElementById('propBgColor').value = hex;
        document.getElementById('propBgColorHex').value = hex;
        S.eyedropActive = false;
        overlay.style.cursor = '';
        if (S.mode === 'pan') overlay.classList.add('pan-mode');
        showToast('배경색 선택 완료', 'success');
    });

    function getSelRect() {
        const x = Math.min(S.selStart.x, S.selEnd.x);
        const y = Math.min(S.selStart.y, S.selEnd.y);
        return { x, y, w: Math.abs(S.selEnd.x - S.selStart.x), h: Math.abs(S.selEnd.y - S.selStart.y) };
    }

    function drawSelBox() {
        clearSelBox();
        const r = getSelRect();
        const box = document.createElement('div');
        box.className = 'sel-box';
        box.style.cssText = `left:${r.x}px;top:${r.y}px;width:${r.w}px;height:${r.h}px`;
        overlay.appendChild(box);
    }

    function clearSelBox() {
        overlay.querySelectorAll('.sel-box').forEach(b => b.remove());
    }

    function detectBg(rect) {
        const img = ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
        const colors = {};
        for (let i = 0; i < img.data.length; i += 4) {
            const k = `${Math.round(img.data[i]/8)*8},${Math.round(img.data[i+1]/8)*8},${Math.round(img.data[i+2]/8)*8}`;
            colors[k] = (colors[k] || 0) + 1;
        }
        let mk = '', mc = 0;
        for (const [k, v] of Object.entries(colors)) { if (v > mc) { mc = v; mk = k; } }
        const [r, g, b] = mk.split(',').map(Number);
        const hex = rgbHex(r, g, b);
        document.getElementById('propBgColor').value = hex;
        document.getElementById('propBgColorHex').value = hex;
    }

    // ═══════════════════════════════
    //  AI 텍스트 분석 (우측 패널 기반)
    // ═══════════════════════════════
    document.getElementById('btnAiAnalyze').addEventListener('click', async () => {
        if (!S.pendingRect) return;
        const rect = S.pendingRect;

        // 배경색 + 텍스트 속성 감지
        const bgColor = document.getElementById('propBgColor').value;
        applyDetectedProps(rect, bgColor);

        // OCR 실행
        const sec = document.getElementById('sectionOcr');
        sec.style.display = 'block';
        document.getElementById('ocrText').textContent = 'AI 텍스트 분석 중...';

        try {
            const tmp = document.createElement('canvas');
            tmp.width = rect.w; tmp.height = rect.h;
            tmp.getContext('2d').drawImage(canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);

            const result = await Tesseract.recognize(tmp.toDataURL('image/png'), 'kor+eng', {
                logger: m => {
                    if (m.status === 'recognizing text')
                        document.getElementById('ocrText').textContent = `AI 분석 중... ${Math.round(m.progress * 100)}%`;
                }
            });

            sec.style.display = 'none';
            const text = result.data.text.trim();

            // 우측 패널에 결과 표시
            document.getElementById('recognizedText').textContent = text || '(텍스트 미감지)';
            document.getElementById('propContent').value = text;
            document.getElementById('sectionEditArea').style.display = 'block';

            showToast(text ? 'AI 분석 완료' : '텍스트 미감지 - 직접 입력하세요', text ? 'success' : '');
        } catch (err) {
            sec.style.display = 'none';
            console.error(err);
            document.getElementById('recognizedText').textContent = '(분석 오류)';
            document.getElementById('propContent').value = '';
            document.getElementById('sectionEditArea').style.display = 'block';
            showToast('AI 분석 오류 발생', 'error');
        }
    });

    // ═══════════════════════════════
    //  변경 사항 적용 (배경색 사각형 + 텍스트 오버레이)
    // ═══════════════════════════════
    document.getElementById('btnApplyChanges').addEventListener('click', () => {
        if (!S.pendingRect) return;
        const rect = S.pendingRect;
        const text = document.getElementById('propContent').value;
        const bgColor = document.getElementById('propBgColor').value;
        const pad = parseInt(document.getElementById('propPad').value);
        const isBold = document.getElementById('propBoldBtn').classList.contains('active');
        const styles = {
            font: document.getElementById('propFont').value,
            fontSize: parseInt(document.getElementById('propSize').value),
            fontWeight: isBold ? '700' : '400',
            color: document.getElementById('propColor').value,
            letterSpacing: parseFloat(document.getElementById('propLetterSp').value),
            scaleX: document.getElementById('propScaleX').value / 100,
            lineHeight: parseFloat(document.getElementById('propLineH').value)
        };

        clearSelBox();

        const data = { bgColor, text, rect: {...rect}, styles, padding: pad };
        if (!S.editLayers[S.currentPage]) S.editLayers[S.currentPage] = [];
        S.editLayers[S.currentPage].push(data);

        createTextObject(data);
        addProcessed(`슬라이드 ${S.currentPage} 텍스트 수정`);
        updateThumbFromSource(S.currentPage);
        showToast('변경 사항 적용 완료', 'success');

        // 우측 패널 초기화
        S.pendingRect = null;
        document.getElementById('sectionEditArea').style.display = 'none';
        const btn = document.getElementById('btnAiAnalyze');
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
        document.getElementById('aiHint').textContent = 'Drag Selection 모드에서 텍스트 영역을 드래그하세요';
        document.getElementById('aiHint').style.color = '#64748b';
    });

    // 색상 picker ↔ hex input 동기화
    document.getElementById('propColor').addEventListener('input', (e) => {
        document.getElementById('propColorHex').value = e.target.value;
        document.getElementById('tbColor').value = e.target.value;
    });
    document.getElementById('propColorHex').addEventListener('change', (e) => {
        if (/^#[0-9a-fA-F]{6}$/.test(e.target.value)) {
            document.getElementById('propColor').value = e.target.value;
            document.getElementById('tbColor').value = e.target.value;
        }
    });
    document.getElementById('propBgColor').addEventListener('input', (e) => {
        document.getElementById('propBgColorHex').value = e.target.value;
        document.getElementById('tbBgColor').value = e.target.value;
    });
    document.getElementById('propBgColorHex').addEventListener('change', (e) => {
        if (/^#[0-9a-fA-F]{6}$/.test(e.target.value)) {
            document.getElementById('propBgColor').value = e.target.value;
            document.getElementById('tbBgColor').value = e.target.value;
        }
    });

    // Bold/Italic 토글
    document.getElementById('propBoldBtn').addEventListener('click', () => {
        document.getElementById('propBoldBtn').classList.toggle('active');
    });
    document.getElementById('propItalicBtn').addEventListener('click', () => {
        document.getElementById('propItalicBtn').classList.toggle('active');
    });

    // 장평 slider ↔ input 동기화
    document.getElementById('propScaleX').addEventListener('input', () => {
        const v = document.getElementById('propScaleX').value;
        document.getElementById('propScaleXNum').value = v;
        document.getElementById('valScaleX').textContent = v + '%';
    });
    document.getElementById('propScaleXNum').addEventListener('input', () => {
        const v = document.getElementById('propScaleXNum').value;
        document.getElementById('propScaleX').value = v;
        document.getElementById('valScaleX').textContent = v + '%';
    });

    // 여백 표시
    document.getElementById('propPad').addEventListener('input', () => {
        document.getElementById('valPad').textContent = document.getElementById('propPad').value + 'px';
    });

    // (old confirmEdit / applyStyles removed - replaced by btnApplyChanges)

    function updateThumb(p) {
        const th = document.querySelector(`.slide-thumb[data-page="${p}"] canvas`);
        if (th) {
            const tc = th.getContext('2d');
            tc.clearRect(0, 0, th.width, th.height);
            tc.drawImage(canvas, 0, 0, th.width, th.height);
        }
    }

    // 원본 + 편집내용을 캔버스에 렌더링 후 썸네일 업데이트
    async function updateThumbFromSource(p) {
        // 원본 복원 후 편집 내용을 캔버스에 그려서 썸네일 생성
        if (S.originals[p]) ctx.putImageData(S.originals[p], 0, 0);
        renderEditsToCanvas(p);
        // 이미지 레이어도 캔버스에 그리기
        const imgLayers = S.imageLayers[p] || [];
        for (const il of imgLayers) {
            const imgEl = await loadImg(il.src);
            ctx.drawImage(imgEl, il.x, il.y, il.w, il.h);
        }
        updateThumb(p);
        // 다시 원본으로 복원 (DOM 텍스트/이미지 객체가 표시 담당)
        if (S.originals[p]) ctx.putImageData(S.originals[p], 0, 0);
    }

    // ═══════════════════════════════
    //  DELETE MODE
    // ═══════════════════════════════
    document.getElementById('btnDeleteMode').addEventListener('click', () => {
        S.deleteMode = !S.deleteMode;
        const btn = document.getElementById('btnDeleteMode');
        btn.classList.toggle('active', S.deleteMode);
        overlay.classList.toggle('delete-mode', S.deleteMode);
        if (S.deleteMode) {
            showToast('삭제 모드: 좌측 썸네일을 클릭하여 삭제할 슬라이드를 선택하세요');
        }
    });

    function toggleDeletePage(p, div) {
        if (S.deletedPages.has(p)) {
            S.deletedPages.delete(p);
            div.classList.remove('marked-delete');
        } else {
            if (S.totalPages - S.deletedPages.size <= 1) {
                showToast('최소 1개 슬라이드가 필요합니다', 'error');
                return;
            }
            S.deletedPages.add(p);
            div.classList.add('marked-delete');
        }
        updateBottomBar();
        addProcessed(`슬라이드 ${p} ${S.deletedPages.has(p) ? '삭제 표시' : '삭제 해제'}`);
    }

    // ═══════════════════════════════
    //  LOGO REMOVAL
    // ═══════════════════════════════
    document.getElementById('btnLogoRemove').addEventListener('click', () => {
        S.logoVisible = !S.logoVisible;
        document.getElementById('sectionLogo').style.display = S.logoVisible ? 'block' : 'none';
        if (S.logoVisible) updateLogoMarker();
    });

    function getLogoRect() {
        const w = parseInt(document.getElementById('logoW').value) * S.scale;
        const h = parseInt(document.getElementById('logoH').value) * S.scale;
        const m = 10 * S.scale;
        const pos = document.getElementById('logoPos').value;
        let x, y;
        switch (pos) {
            case 'bottom-right': x = canvas.width - w - m; y = canvas.height - h - m; break;
            case 'bottom-left': x = m; y = canvas.height - h - m; break;
            case 'top-right': x = canvas.width - w - m; y = m; break;
            case 'top-left': x = m; y = m; break;
        }
        return { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
    }

    function updateLogoMarker() {
        const mk = document.getElementById('logoMarkerVis');
        const pos = document.getElementById('logoPos').value;
        const m = '5%', w = '35%', h = '25%';
        switch (pos) {
            case 'bottom-right': mk.style.cssText = `right:${m};bottom:${m};width:${w};height:${h}`; break;
            case 'bottom-left': mk.style.cssText = `left:${m};bottom:${m};width:${w};height:${h}`; break;
            case 'top-right': mk.style.cssText = `right:${m};top:${m};width:${w};height:${h}`; break;
            case 'top-left': mk.style.cssText = `left:${m};top:${m};width:${w};height:${h}`; break;
        }
    }

    ['logoPos','logoW','logoH'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => {
            document.getElementById('valLogoW').textContent = document.getElementById('logoW').value;
            document.getElementById('valLogoH').textContent = document.getElementById('logoH').value;
            updateLogoMarker();
        });
    });

    function analyzeLogoBg(rect) {
        const sr = 20 * S.scale;
        const colors = {};
        const areas = [
            { x: rect.x, y: Math.max(0, rect.y - sr), w: rect.w, h: Math.min(sr, rect.y) },
            { x: rect.x, y: rect.y + rect.h, w: rect.w, h: Math.min(sr, canvas.height - rect.y - rect.h) },
            { x: Math.max(0, rect.x - sr), y: rect.y, w: Math.min(sr, rect.x), h: rect.h },
            { x: rect.x + rect.w, y: rect.y, w: Math.min(sr, canvas.width - rect.x - rect.w), h: rect.h }
        ];
        areas.forEach(a => {
            if (a.w <= 0 || a.h <= 0) return;
            const d = ctx.getImageData(a.x, a.y, a.w, a.h);
            for (let i = 0; i < d.data.length; i += 4) {
                const k = `${Math.round(d.data[i]/4)*4},${Math.round(d.data[i+1]/4)*4},${Math.round(d.data[i+2]/4)*4}`;
                colors[k] = (colors[k] || 0) + 1;
            }
        });
        let mk = '255,255,255', mc = 0;
        for (const [k, v] of Object.entries(colors)) { if (v > mc) { mc = v; mk = k; } }
        const [r, g, b] = mk.split(',').map(Number);
        return `rgb(${r},${g},${b})`;
    }

    document.getElementById('btnLogoOneRemove').addEventListener('click', async () => {
        if (S.originals[S.currentPage]) ctx.putImageData(S.originals[S.currentPage], 0, 0);
        reapplyEdits(S.currentPage);
        const rect = getLogoRect();
        ctx.fillStyle = analyzeLogoBg(rect);
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        updateThumb(S.currentPage);
        addProcessed(`슬라이드 ${S.currentPage} 로고 삭제`);
        showToast('로고 삭제 완료', 'success');
    });

    document.getElementById('btnLogoAllRemove').addEventListener('click', async () => {
        for (let i = 1; i <= S.totalPages; i++) {
            await renderPage(i);
            const rect = getLogoRect();
            ctx.fillStyle = analyzeLogoBg(rect);
            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
            updateThumb(i);
        }
        await renderPage(1);
        addProcessed(`전체 슬라이드 로고 삭제 (${S.totalPages}장)`);
        showToast(`${S.totalPages}개 슬라이드 로고 삭제 완료!`, 'success');
    });

    // ═══════════════════════════════
    //  LOAD (PPTX 불러오기)
    // ═══════════════════════════════
    // ═══════════════════════════════
    //  파일 열기 (PDF / PPTX)
    // ═══════════════════════════════
    document.getElementById('btnOpenFile').addEventListener('click', () => {
        document.getElementById('openFileInput').click();
    });

    document.getElementById('openFileInput').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        e.target.value = '';

        const ext = file.name.split('.').pop().toLowerCase();

        if (ext === 'pdf') {
            showToast('PDF 불러오는 중...', 'success');
            try {
                const arrayBuffer = await file.arrayBuffer();

                // IndexedDB에 저장
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.put(arrayBuffer, 'pdf_data');
                store.put(file.name, 'pdf_fileName');
                store.put(file.size, 'pdf_fileSize');
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = reject;
                });
                db.close();

                localStorage.setItem('pdf_type', 'pdf');
                localStorage.setItem('pdf_fileName', file.name);
                localStorage.setItem('pdf_fileSize', file.size.toString());

                // 상태 초기화 후 PDF 모드로 로드
                S.slideImages = null;
                S.imageLayers = {};
                await loadPdf(arrayBuffer, file.name);
            } catch (err) {
                console.error('PDF 불러오기 오류:', err);
                showToast('PDF 불러오기 중 오류가 발생했습니다.', 'error');
            }
        } else if (ext === 'pptx') {
            // 기존 PPTX 불러오기 로직 재사용
            const fakeEvent = { target: { files: [file], value: '' } };
            await handlePptxImport(fakeEvent);
        } else {
            showToast('PDF 또는 PPTX 파일만 지원합니다.', 'error');
        }
    });

    document.getElementById('btnImportPptx').addEventListener('click', () => {
        let pptxInput = document.getElementById('pptxFileInput');
        if (!pptxInput) {
            pptxInput = document.createElement('input');
            pptxInput.type = 'file';
            pptxInput.id = 'pptxFileInput';
            pptxInput.accept = '.pptx';
            pptxInput.style.display = 'none';
            document.body.appendChild(pptxInput);
            pptxInput.addEventListener('change', handlePptxImport);
        }
        pptxInput.click();
    });

    async function handlePptxImport(e) {
        const file = e.target.files[0];
        if (!file) return;
        e.target.value = '';

        showToast('PPTX 불러오는 중...', 'success');

        try {
            const arrayBuffer = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);

            // PPTX에서 슬라이드 이미지 추출
            const imageFiles = Object.keys(zip.files)
                .filter(f => /^ppt\/media\/image\d+\.(png|jpg|jpeg)$/i.test(f))
                .sort((a, b) => {
                    const na = parseInt(a.match(/image(\d+)/)[1]);
                    const nb = parseInt(b.match(/image(\d+)/)[1]);
                    return na - nb;
                });

            if (imageFiles.length === 0) {
                showToast('PPTX에서 슬라이드 이미지를 찾을 수 없습니다.', 'error');
                return;
            }

            const slideImages = [];
            for (const imgFile of imageFiles) {
                const blob = await zip.files[imgFile].async('blob');
                const dataUrl = await new Promise(resolve => {
                    const r = new FileReader();
                    r.onload = () => resolve(r.result);
                    r.readAsDataURL(blob);
                });
                slideImages.push(dataUrl);
            }

            // IndexedDB에 저장
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.put(slideImages, 'slide_images');
            store.put(file.name, 'pdf_fileName');
            store.put(file.size, 'pdf_fileSize');
            store.put(slideImages.length, 'pdf_pages');
            await new Promise((resolve, reject) => {
                tx.oncomplete = resolve;
                tx.onerror = reject;
            });
            db.close();

            localStorage.setItem('pdf_type', 'pptx');
            localStorage.setItem('pdf_fileName', file.name);
            localStorage.setItem('pdf_fileSize', file.size.toString());
            localStorage.setItem('pdf_pages', slideImages.length.toString());

            // 에디터 상태 초기화 후 PPTX 모드로 재로드
            S.pdfDoc = null;
            S.slideImages = slideImages;
            S.totalPages = slideImages.length;
            S.currentPage = 1;
            S.editLayers = {};
            S.imageLayers = {};
            S.originals = {};
            S.deletedPages.clear();

            document.getElementById('fileNameDisplay').textContent = file.name;
            document.getElementById('totalPagesLabel').textContent = S.totalPages;

            buildThumbs();
            buildBottomBar();
            await renderPage(1);
            updateZoomLabel();
            showToast(`${file.name} 불러오기 완료 (${S.totalPages}페이지)`, 'success');

        } catch (err) {
            console.error('PPTX 불러오기 오류:', err);
            showToast('PPTX 불러오기 중 오류가 발생했습니다.', 'error');
        }
    }

    // ═══════════════════════════════
    //  SAVE (PPTX)
    // ═══════════════════════════════
    document.getElementById('btnExport').addEventListener('click', () => {
        savePptx();
    });
    document.getElementById('exportCancel').addEventListener('click', () => {
        document.getElementById('exportModal').classList.remove('active');
    });

    async function savePptx() {
        const prog = document.getElementById('exportProgress');
        const bar = document.getElementById('exportProgressBar');
        const txt = document.getElementById('exportProgressText');
        document.getElementById('exportBtns').style.display = 'none';
        prog.style.display = 'block';
        document.getElementById('exportModal').classList.add('active');

        try {
            const pptx = new PptxGenJS();
            const savedPage = S.currentPage;
            const exportScale = 2.0;
            const activePages = [];

            for (let i = 1; i <= S.totalPages; i++) {
                if (!S.deletedPages.has(i)) activePages.push(i);
            }

            for (let idx = 0; idx < activePages.length; idx++) {
                const i = activePages[idx];
                const pct = Math.round(((idx + 1) / activePages.length) * 100);
                bar.style.width = pct + '%';
                txt.textContent = `슬라이드 ${i} / ${S.totalPages} 저장 중... (${pct}%)`;

                // 슬라이드 원본 렌더링 (PDF 또는 이미지)
                if (S.pdfDoc) {
                    const page = await S.pdfDoc.getPage(i);
                    const vp = page.getViewport({ scale: exportScale });
                    canvas.width = vp.width;
                    canvas.height = vp.height;
                    await page.render({ canvasContext: ctx, viewport: vp }).promise;
                } else if (S.slideImages) {
                    const img = await loadImg(S.slideImages[i - 1]);
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                }

                // 편집 내용을 export scale로 다시 그리기
                const ratio = S.pdfDoc ? (exportScale / S.scale) : (canvas.width / (S.originals[i] ? S.originals[i].width : canvas.width));
                (S.editLayers[i] || []).forEach(l => {
                    const scaled = {
                        bgColor: l.bgColor,
                        text: l.text,
                        padding: Math.round(l.padding * ratio),
                        rect: {
                            x: Math.round(l.rect.x * ratio),
                            y: Math.round(l.rect.y * ratio),
                            w: Math.round(l.rect.w * ratio),
                            h: Math.round(l.rect.h * ratio)
                        },
                        styles: {
                            ...l.styles,
                            fontSize: Math.round(l.styles.fontSize * ratio),
                            letterSpacing: l.styles.letterSpacing * ratio
                        }
                    };
                    paintEditOnCanvas(scaled);
                });

                // 이미지 레이어도 export scale로 렌더링
                const imgLayersForPage = S.imageLayers ? (S.imageLayers[i] || []) : [];
                for (const il of imgLayersForPage) {
                    const imgEl = await loadImg(il.src);
                    ctx.drawImage(imgEl, Math.round(il.x * ratio), Math.round(il.y * ratio), Math.round(il.w * ratio), Math.round(il.h * ratio));
                }

                const imgData = canvas.toDataURL('image/png');
                const slideW = 10;
                const slideH = slideW * (canvas.height / canvas.width);
                pptx.defineLayout({ name: 'SLIDE', width: slideW, height: slideH });
                pptx.layout = 'SLIDE';

                const slide = pptx.addSlide();
                slide.addImage({ data: imgData, x: 0, y: 0, w: slideW, h: slideH });

                await new Promise(r => setTimeout(r, 50));
            }

            txt.textContent = 'PPTX 파일 생성 중...';
            const fileName = (localStorage.getItem('pdf_fileName') || 'slides').replace(/\.(pdf|pptx)$/i, '');
            await pptx.writeFile({ fileName: fileName + '.pptx' });

            await renderPage(savedPage);
            document.getElementById('exportModal').classList.remove('active');
            showToast(`PPTX 저장 완료 (${activePages.length}슬라이드)`, 'success');
            addProcessed(`PPTX 저장 (${activePages.length}장)`);
        } catch (err) {
            console.error(err);
            prog.style.display = 'none';
            document.getElementById('exportBtns').style.display = 'flex';
            showToast('PPTX 저장 중 오류 발생', 'error');
        }
    }

    // ═══════════════════════════════
    //  PROCESSED LIST
    // ═══════════════════════════════
    function addProcessed(msg) {
        const list = document.getElementById('historyPanelBody');
        // 빈 상태 메시지 제거
        const empty = list.querySelector('div[style]');
        if (empty) empty.remove();
        const item = document.createElement('div');
        item.className = 'processed-item';
        item.innerHTML = `<span class="processed-dot done"></span>${msg}`;
        list.prepend(item);
    }

    // ═══════════════════════════════
    //  KEYBOARD SHORTCUTS
    // ═══════════════════════════════
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

        if (e.key === 'ArrowLeft' && S.currentPage > 1) renderPage(S.currentPage - 1);
        if (e.key === 'ArrowRight' && S.currentPage < S.totalPages) renderPage(S.currentPage + 1);

        // Ctrl+Z: 실행취소
        if (e.ctrlKey && e.key === 'z') {
            undoLastEdit();
        }
    });

    // ═══════════════════════════════
    //  TOOLBAR SYNC (도구 모음 ↔ 우측 패널 양방향 동기화)
    // ═══════════════════════════════
    const tbSyncMap = [
        ['tbFont', 'propFont'],
        ['tbFontSize', 'propSize'],
        ['tbColor', 'propColor'],
        ['tbBgColor', 'propBgColor'],
        ['tbLetterSp', 'propLetterSp'],
        ['tbScaleX', 'propScaleX'],
        ['tbLineH', 'propLineH']
    ];

    tbSyncMap.forEach(([tbId, rpId]) => {
        const tbEl = document.getElementById(tbId);
        const rpEl = document.getElementById(rpId);
        if (!tbEl || !rpEl) return;

        tbEl.addEventListener('input', () => {
            rpEl.value = tbEl.value;
            rpEl.dispatchEvent(new Event('input'));
        });
        rpEl.addEventListener('input', () => {
            tbEl.value = rpEl.value;
        });
    });

    // Bold 토글 (도구 모음 ↔ 우측 패널 동기화)
    document.getElementById('tbBold').addEventListener('click', () => {
        const tbBtn = document.getElementById('tbBold');
        const rpBtn = document.getElementById('propBoldBtn');
        const isActive = rpBtn.classList.contains('active');
        rpBtn.classList.toggle('active', !isActive);
        tbBtn.classList.toggle('active', !isActive);
    });

    // Italic 토글 (도구 모음 ↔ 우측 패널 동기화)
    document.getElementById('tbItalic').addEventListener('click', () => {
        const tbBtn = document.getElementById('tbItalic');
        const rpBtn = document.getElementById('propItalicBtn');
        const isActive = rpBtn.classList.contains('active');
        rpBtn.classList.toggle('active', !isActive);
        tbBtn.classList.toggle('active', !isActive);
    });

    // 도구 모음 스포이드
    document.getElementById('tbEyedrop').addEventListener('click', () => {
        S.eyedropActive = true;
        overlay.style.cursor = 'crosshair';
        overlay.classList.remove('pan-mode');
        showToast('캔버스를 클릭하여 배경색을 선택하세요');
    });

    function undoLastEdit() {
        const layers = S.editLayers[S.currentPage];
        if (layers && layers.length > 0) {
            layers.pop();
            // 원본 복원 후 남은 편집 내용 다시 그리기
            if (S.originals[S.currentPage]) {
                ctx.putImageData(S.originals[S.currentPage], 0, 0);
            }
            reapplyEdits(S.currentPage);
            updateThumb(S.currentPage);
            S.selectedObject = null;
            showToast('실행 취소', 'success');
        }
    }

    // 도구 모음 실행취소
    document.getElementById('tbUndo').addEventListener('click', () => {
        undoLastEdit();
    });

    // 뷰포트에 맞는 최적 줌 비율 계산
    async function calcFitScale(page) {
        if (!page) page = await S.pdfDoc.getPage(S.currentPage);
        const baseVp = page.getViewport({ scale: 1 });
        const vpEl = document.getElementById('canvasViewport');
        // 뷰포트 영역에서 패딩을 뺀 사용 가능 공간
        const availW = vpEl.clientWidth - 60;
        const availH = vpEl.clientHeight - 60;
        const scaleW = availW / baseVp.width;
        const scaleH = availH / baseVp.height;
        // 더 작은 쪽에 맞추고, 약간 여유(95%)를 두어 상하좌우 여백 확보
        const fit = Math.min(scaleW, scaleH) * 0.95;
        return Math.max(0.3, Math.min(3, fit));
    }

    // 줌 컨트롤
    function updateZoomLabel() {
        document.getElementById('tbZoomLabel').textContent = Math.round(S.scale * 100) + '%';
    }

    document.getElementById('tbZoomIn').addEventListener('click', () => {
        S.scale = Math.min(4, S.scale + 0.25);
        renderPage(S.currentPage);
        updateZoomLabel();
    });

    document.getElementById('tbZoomOut').addEventListener('click', () => {
        S.scale = Math.max(0.3, S.scale - 0.25);
        renderPage(S.currentPage);
        updateZoomLabel();
    });

    document.getElementById('tbZoomFit').addEventListener('click', async () => {
        S.scale = await calcFitScale();
        renderPage(S.currentPage);
        updateZoomLabel();
    });

    // ═══════════════════════════════
    //  UTILS
    // ═══════════════════════════════
    function rgbHex(r, g, b) {
        return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function showToast(msg, type = '') {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.className = 'toast ' + type;
        setTimeout(() => t.classList.add('show'), 10);
        setTimeout(() => t.classList.remove('show'), 3000);
    }

    // ═══════════════════════════════
    //  좌측 아이콘 바 이벤트
    // ═══════════════════════════════
    let activeLeftPanel = null;

    function toggleLeftPanel(panelId, iconBtn) {
        const panel = document.getElementById(panelId);
        const isOpen = panel.classList.contains('active');

        // 모든 패널 닫기
        document.querySelectorAll('.left-overlay-panel').forEach(p => p.classList.remove('active'));
        document.querySelectorAll('.icon-bar-btn').forEach(b => b.classList.remove('active'));

        if (!isOpen) {
            panel.classList.add('active');
            iconBtn.classList.add('active');
            activeLeftPanel = panelId;
            if (panelId === 'layerPanel') refreshLayerPanel();
        } else {
            activeLeftPanel = null;
        }
    }

    document.getElementById('iconHistory').addEventListener('click', function() {
        toggleLeftPanel('historyPanel', this);
    });

    document.getElementById('iconDelete').addEventListener('click', function() {
        // 삭제 모드 토글 (기존 btnDeleteMode와 동일)
        S.deleteMode = !S.deleteMode;
        const btn = document.getElementById('btnDeleteMode');
        btn.classList.toggle('active', S.deleteMode);
        this.classList.toggle('active', S.deleteMode);
        overlay.classList.toggle('delete-mode', S.deleteMode);
        if (S.deleteMode) {
            showToast('삭제 모드: 좌측 썸네일을 클릭하여 삭제할 슬라이드를 선택하세요');
        }
    });

    document.getElementById('iconLayers').addEventListener('click', function() {
        toggleLeftPanel('layerPanel', this);
    });

    document.getElementById('closeHistory').addEventListener('click', () => {
        document.getElementById('historyPanel').classList.remove('active');
        document.getElementById('iconHistory').classList.remove('active');
        activeLeftPanel = null;
    });

    document.getElementById('closeLayer').addEventListener('click', () => {
        document.getElementById('layerPanel').classList.remove('active');
        document.getElementById('iconLayers').classList.remove('active');
        activeLeftPanel = null;
    });

    // ═══════════════════════════════
    //  레이어 관리
    // ═══════════════════════════════
    function refreshLayerPanel() {
        const body = document.getElementById('layerPanelBody');
        const layers = S.editLayers[S.currentPage] || [];
        const imgLayers = S.imageLayers ? (S.imageLayers[S.currentPage] || []) : [];

        if (layers.length === 0 && imgLayers.length === 0) {
            body.innerHTML = '<div style="font-size:11px; color:#64748b; text-align:center; padding:12px 0;">편집 객체가 없습니다</div>';
            return;
        }

        body.innerHTML = '';
        let idx = 0;

        // 텍스트 레이어
        layers.forEach((l, i) => {
            const item = document.createElement('div');
            item.className = 'layer-item';
            item.dataset.type = 'text';
            item.dataset.index = i;
            const preview = (l.text || '').substring(0, 20) || '(빈 텍스트)';
            item.innerHTML = `
                <div class="layer-icon text">T</div>
                <div class="layer-info">
                    <div class="layer-info-name">${preview}</div>
                    <div class="layer-info-type">텍스트</div>
                </div>
                <div class="layer-actions">
                    <button class="layer-action-btn" data-action="up" title="위로">&#9650;</button>
                    <button class="layer-action-btn" data-action="down" title="아래로">&#9660;</button>
                    <button class="layer-action-btn danger" data-action="delete" title="삭제">&#10005;</button>
                </div>
            `;
            item.querySelectorAll('.layer-action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleLayerAction(btn.dataset.action, 'text', i);
                });
            });
            body.appendChild(item);
            idx++;
        });

        // 이미지 레이어
        imgLayers.forEach((l, i) => {
            const item = document.createElement('div');
            item.className = 'layer-item';
            item.dataset.type = 'image';
            item.dataset.index = i;
            item.innerHTML = `
                <div class="layer-icon image">&#128247;</div>
                <div class="layer-info">
                    <div class="layer-info-name">${l.name || '이미지'}</div>
                    <div class="layer-info-type">이미지</div>
                </div>
                <div class="layer-actions">
                    <button class="layer-action-btn" data-action="up" title="위로">&#9650;</button>
                    <button class="layer-action-btn" data-action="down" title="아래로">&#9660;</button>
                    <button class="layer-action-btn danger" data-action="delete" title="삭제">&#10005;</button>
                </div>
            `;
            item.querySelectorAll('.layer-action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleLayerAction(btn.dataset.action, 'image', i);
                });
            });
            body.appendChild(item);
        });
    }

    function handleLayerAction(action, type, index) {
        const p = S.currentPage;
        const arr = type === 'text' ? (S.editLayers[p] || []) : (S.imageLayers ? (S.imageLayers[p] || []) : []);

        if (action === 'delete') {
            if (type === 'text') {
                const data = arr[index];
                arr.splice(index, 1);
                // DOM에서도 해당 텍스트 객체 제거
                const objs = container.querySelectorAll('.text-object');
                objs.forEach(obj => { if (obj._editData === data) obj.remove(); });
                updateThumbFromSource(p);
                addProcessed(`슬라이드 ${p} 텍스트 삭제`);
            } else {
                const data = arr[index];
                arr.splice(index, 1);
                const objs = container.querySelectorAll('.image-object');
                objs.forEach(obj => { if (obj._imgData === data) obj.remove(); });
                updateThumbFromSource(p);
                addProcessed(`슬라이드 ${p} 이미지 삭제`);
            }
        } else if (action === 'up' && index > 0) {
            [arr[index - 1], arr[index]] = [arr[index], arr[index - 1]];
        } else if (action === 'down' && index < arr.length - 1) {
            [arr[index], arr[index + 1]] = [arr[index + 1], arr[index]];
        }

        refreshLayerPanel();
        showToast(action === 'delete' ? '객체 삭제됨' : '순서 변경됨', 'success');
    }

    // ═══════════════════════════════
    //  이미지 추가 기능
    // ═══════════════════════════════
    document.getElementById('btnAddImage').addEventListener('click', () => {
        document.getElementById('imageFileInput').click();
    });

    document.getElementById('imageFileInput').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        e.target.value = '';

        const reader = new FileReader();
        reader.onload = (ev) => {
            const dataUrl = ev.target.result;
            const img = new Image();
            img.onload = () => {
                // 캔버스 크기 대비 적절한 초기 크기 계산
                const maxW = canvas.width * 0.4;
                const maxH = canvas.height * 0.4;
                let w = img.width, h = img.height;
                if (w > maxW) { h = h * (maxW / w); w = maxW; }
                if (h > maxH) { w = w * (maxH / h); h = maxH; }

                const imgData = {
                    type: 'image',
                    src: dataUrl,
                    name: file.name,
                    x: 20,
                    y: 20,
                    w: Math.round(w),
                    h: Math.round(h),
                    naturalW: img.width,
                    naturalH: img.height
                };

                if (!S.imageLayers[S.currentPage]) S.imageLayers[S.currentPage] = [];
                S.imageLayers[S.currentPage].push(imgData);

                createImageObject(imgData);
                addProcessed(`슬라이드 ${S.currentPage} 이미지 추가`);
                showToast('이미지 추가 완료', 'success');
                if (activeLeftPanel === 'layerPanel') refreshLayerPanel();
            };
            img.src = dataUrl;
        };
        reader.readAsDataURL(file);
    });

    function createImageObject(data) {
        const div = document.createElement('div');
        div.className = 'image-object';
        div.style.left = data.x + 'px';
        div.style.top = data.y + 'px';
        div.style.width = data.w + 'px';
        div.style.height = data.h + 'px';

        const img = document.createElement('img');
        img.src = data.src;
        img.draggable = false;
        div.appendChild(img);

        // 액션 버튼
        const actions = document.createElement('div');
        actions.className = 'text-object-actions';
        const btnDel = document.createElement('button');
        btnDel.className = 'to-btn to-btn-del';
        btnDel.innerHTML = '&#10005;';
        btnDel.title = '삭제';
        actions.appendChild(btnDel);
        div.appendChild(actions);

        // 리사이즈 핸들
        const handle = document.createElement('div');
        handle.className = 'image-resize-handle br';
        div.appendChild(handle);

        div._imgData = data;

        // 클릭 → 선택
        div.addEventListener('mousedown', (e) => {
            if (e.target === handle) return;
            if (S.mode !== 'select') return;
            e.stopPropagation();
            selectImageObject(div);

            const startX = e.clientX, startY = e.clientY;
            const origLeft = parseInt(div.style.left), origTop = parseInt(div.style.top);

            function onMove(ev) {
                div.style.left = (origLeft + ev.clientX - startX) + 'px';
                div.style.top = (origTop + ev.clientY - startY) + 'px';
            }
            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                data.x = parseInt(div.style.left);
                data.y = parseInt(div.style.top);
            }
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });

        // 리사이즈
        handle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            e.preventDefault();
            const startX = e.clientX, startY = e.clientY;
            const origW = parseInt(div.style.width), origH = parseInt(div.style.height);
            const ratio = origW / origH;

            function onMove(ev) {
                const dw = ev.clientX - startX;
                let newW = Math.max(30, origW + dw);
                let newH = newW / ratio;
                div.style.width = Math.round(newW) + 'px';
                div.style.height = Math.round(newH) + 'px';
            }
            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                data.w = parseInt(div.style.width);
                data.h = parseInt(div.style.height);
            }
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });

        // 삭제
        btnDel.addEventListener('click', (e) => {
            e.stopPropagation();
            const layers = S.imageLayers[S.currentPage];
            if (layers) {
                const idx = layers.indexOf(data);
                if (idx !== -1) layers.splice(idx, 1);
            }
            div.remove();
            addProcessed(`슬라이드 ${S.currentPage} 이미지 삭제`);
            showToast('이미지 삭제됨', 'success');
            if (activeLeftPanel === 'layerPanel') refreshLayerPanel();
        });

        container.appendChild(div);
        return div;
    }

    function selectImageObject(div) {
        container.querySelectorAll('.image-object.selected').forEach(el => el.classList.remove('selected'));
        container.querySelectorAll('.text-object.selected').forEach(el => el.classList.remove('selected'));
        div.classList.add('selected');
    }

    // ═══════════════════════════════
    //  PDF 내보내기
    // ═══════════════════════════════
    document.getElementById('btnExportPdf').addEventListener('click', () => {
        savePdf();
    });

    async function savePdf() {
        const prog = document.getElementById('exportProgress');
        const bar = document.getElementById('exportProgressBar');
        const txt = document.getElementById('exportProgressText');
        document.getElementById('exportBtns').style.display = 'none';
        prog.style.display = 'block';
        document.getElementById('exportModal').classList.add('active');

        // 모달 제목 변경
        document.querySelector('#exportModal .modal-box h3').textContent = 'PDF로 내보내기';
        document.querySelector('#exportModal .modal-box p').textContent = '편집된 슬라이드를 PDF 파일로 저장합니다.';

        try {
            const { jsPDF } = window.jspdf;
            const savedPage = S.currentPage;
            const exportScale = 2.0;
            const activePages = [];

            for (let i = 1; i <= S.totalPages; i++) {
                if (!S.deletedPages.has(i)) activePages.push(i);
            }

            // 첫 페이지 렌더링으로 비율 파악
            let firstW, firstH;
            if (S.pdfDoc) {
                const page = await S.pdfDoc.getPage(activePages[0]);
                const vp = page.getViewport({ scale: exportScale });
                firstW = vp.width;
                firstH = vp.height;
            } else if (S.slideImages) {
                const img = await loadImg(S.slideImages[activePages[0] - 1]);
                firstW = img.width;
                firstH = img.height;
            }

            const orientation = firstW > firstH ? 'landscape' : 'portrait';
            const pdf = new jsPDF({
                orientation: orientation,
                unit: 'px',
                format: [firstW, firstH]
            });

            for (let idx = 0; idx < activePages.length; idx++) {
                const i = activePages[idx];
                const pct = Math.round(((idx + 1) / activePages.length) * 100);
                bar.style.width = pct + '%';
                txt.textContent = `슬라이드 ${i} / ${S.totalPages} 저장 중... (${pct}%)`;

                if (idx > 0) pdf.addPage([firstW, firstH], orientation);

                if (S.pdfDoc) {
                    const page = await S.pdfDoc.getPage(i);
                    const vp = page.getViewport({ scale: exportScale });
                    canvas.width = vp.width;
                    canvas.height = vp.height;
                    await page.render({ canvasContext: ctx, viewport: vp }).promise;
                } else if (S.slideImages) {
                    const img = await loadImg(S.slideImages[i - 1]);
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                }

                // 텍스트 편집 내용 렌더링
                const ratio = S.pdfDoc ? (exportScale / S.scale) : (canvas.width / (S.originals[i] ? S.originals[i].width : canvas.width));
                (S.editLayers[i] || []).forEach(l => {
                    const scaled = {
                        bgColor: l.bgColor,
                        text: l.text,
                        padding: Math.round(l.padding * ratio),
                        rect: {
                            x: Math.round(l.rect.x * ratio),
                            y: Math.round(l.rect.y * ratio),
                            w: Math.round(l.rect.w * ratio),
                            h: Math.round(l.rect.h * ratio)
                        },
                        styles: {
                            ...l.styles,
                            fontSize: Math.round(l.styles.fontSize * ratio),
                            letterSpacing: l.styles.letterSpacing * ratio
                        }
                    };
                    paintEditOnCanvas(scaled);
                });

                // 이미지 레이어 렌더링
                const imgLayers = S.imageLayers[i] || [];
                for (const il of imgLayers) {
                    const imgEl = await loadImg(il.src);
                    const sx = ratio;
                    ctx.drawImage(imgEl, Math.round(il.x * sx), Math.round(il.y * sx), Math.round(il.w * sx), Math.round(il.h * sx));
                }

                const imgData = canvas.toDataURL('image/jpeg', 0.92);
                pdf.addImage(imgData, 'JPEG', 0, 0, firstW, firstH);

                await new Promise(r => setTimeout(r, 50));
            }

            txt.textContent = 'PDF 파일 생성 중...';
            const fileName = (localStorage.getItem('pdf_fileName') || 'slides').replace(/\.(pdf|pptx)$/i, '');
            pdf.save(fileName + '.pdf');

            await renderPage(savedPage);
            document.getElementById('exportModal').classList.remove('active');

            // 모달 복원
            document.querySelector('#exportModal .modal-box h3').textContent = 'PPTX로 내보내기';
            document.querySelector('#exportModal .modal-box p').textContent = '편집된 슬라이드를 PowerPoint(.pptx) 파일로 저장합니다.';
            document.getElementById('exportBtns').style.display = 'flex';
            prog.style.display = 'none';

            showToast(`PDF 저장 완료 (${activePages.length}슬라이드)`, 'success');
            addProcessed(`PDF 저장 (${activePages.length}장)`);
        } catch (err) {
            console.error(err);
            prog.style.display = 'none';
            document.getElementById('exportBtns').style.display = 'flex';
            document.querySelector('#exportModal .modal-box h3').textContent = 'PPTX로 내보내기';
            document.querySelector('#exportModal .modal-box p').textContent = '편집된 슬라이드를 PowerPoint(.pptx) 파일로 저장합니다.';
            showToast('PDF 저장 중 오류 발생', 'error');
        }
    }

    // ═══ START ═══
    init();
    </script>
</body>
</html>
